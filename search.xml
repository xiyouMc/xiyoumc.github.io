<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Python爬虫利器---PhamtomJS]]></title>
      <url>https://xiyoumc.github.com/2017/03/30/Python%E7%88%AC%E8%99%AB%E5%88%A9%E5%99%A8---PhamtomJS/</url>
      <content type="html"><![CDATA[<h2 id="Python爬虫利器—PhamtomJS"><a href="#Python爬虫利器—PhamtomJS" class="headerlink" title="Python爬虫利器—PhamtomJS"></a>Python爬虫利器—PhamtomJS</h2><blockquote>
<p>阅读本文需要2.66分钟</p>
</blockquote>
<a id="more"></a>
<p>python爬虫玩多了之后，大家应该会发现有个共性：就是只能爬取单纯的html代码。那么如果页面是JS渲染的该怎么办？</p>
<p>如果我们单纯的去分析每一个后台的请求，手动去摸索JS渲染的一些结果，那么简直是醉了。所以，我们一些好用的工具来帮助我们像浏览器一样渲染JS处理的页面。</p>
<p><code>PhamtomJS</code>  <a href="http://phantomjs.org/" target="_blank" rel="external">http://phantomjs.org</a></p>
<p>引用官网的一句简介:</p>
<p>###Full web stack No browser required</p>
<p> PhantomJS is a headless WebKit scriptable with a JavaScript API. It has fast and native support for various web standards: DOM handling, CSS selector, JSON, Canvas, and SVG.</p>
<p>PhamtomJS是一个无界面的，可脚本编程的WebKit浏览器引擎。它原生支持多种web标准：DOM操作、CSS选择器、JSON、Canvas以及SVG。</p>
<p>具体的安装方法我们就不讲了。这里给个链接 <a href="http://www.tuicool.com/articles/MjUfayI" target="_blank" rel="external">http://www.tuicool.com/articles/MjUfayI</a></p>
<p>那么接下来我们通过抓取 Github 某个仓库渲染之后的主页来进行PhamtomJS的讲解：</p>
<p>效果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">capture</span><span class="params">(url, save_fn=<span class="string">"capture.png"</span>)</span>:</span></div><div class="line">    <span class="keyword">print</span> url</div><div class="line">    browser = webdriver.PhantomJS() <span class="comment"># Get local session of firefox</span></div><div class="line">    browser.set_window_size(<span class="number">1200</span>, <span class="number">900</span>)</div><div class="line">    browser.get(url) </div><div class="line">    browser.save_screenshot(save_fn)</div><div class="line">    browser.close()</div></pre></td></tr></table></figure>
<p>print driver.find_element_by_tag_name(“div”).text<br>print driver.find_element_by_csss_selector(“#content”).text<br>print driver.find_element_by_id(“content”).text</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">find_element_by_tag_name(&quot;div&quot;)</div><div class="line">find_element_by_csss_selector(&quot;#content&quot;)</div><div class="line">find_element_by_id(&quot;content&quot;)</div><div class="line">等等的</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[当我玩哔哩哔哩的时候，一不小心。。。]]></title>
      <url>https://xiyoumc.github.com/2017/03/22/%E5%BD%93%E6%88%91%E7%8E%A9%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B8%80%E4%B8%8D%E5%B0%8F%E5%BF%83%E3%80%82%E3%80%82%E3%80%82/</url>
      <content type="html"><![CDATA[<h2 id="一不小心用代码登陆了B站。。。并上传了。。视频"><a href="#一不小心用代码登陆了B站。。。并上传了。。视频" class="headerlink" title="一不小心用代码登陆了B站。。。并上传了。。视频"></a>一不小心用代码登陆了B站。。。并上传了。。视频</h2><blockquote>
<p>阅读本文需要4.66分钟</p>
</blockquote>
<a id="more"></a>
<p>你被标题吸引了吧。。。别急着关。。重头戏在后面</p>
<p>最近当我玩B站的时候，一不小心用代码登录了它，并几乎无限制的上传视频。</p>
<p>那么接下来，我来讲解如何通过Hack技术来模拟 哔哩哔哩 的登录，并完成我们的视频上传等操作。因此内容中略有“暴力”，若您感到不适，那还是也请看完它。</p>
<p>按照以往的老套路，我们首先需要弄清楚它的登录逻辑，并通过我们的代码来实现登录操作，其次拿到所谓的 Cookie 或者 Token、Sign等校验字段来做其他的操作，以下将围绕 B站 一步步来讲解破解的思路:</p>
<p>首先我们访问到 哔哩哔哩 的登录页面:</p>
<p>  <img src="http://115.28.132.58:8080/docs/BiliLogin.png" alt=""></p>
<p>当我们在未登录的状态下访问登录页面的时候，会发现验证码已经显示出来了。那么他们是怎么做到当我输入账号、密码并输入一个已经出来的验证码之后就能校验成功呢。这时候就得提前动动脑子，当然如果你是开发服务器的话，应该明白里面的道理。这里我简单的讲下，其实在访问这个登录页面的时候，B站 已经将一个唯一的标识和验证码绑定起来了（也就是后面说到的Cookie），并且在登录的时候将这个标识一并发送上去。也就是说：通过一个标识来绑定验证码和登录操作。</p>
<p>那么接下来我们看看在第一次访问登录页面的时候，都有哪些可用的数据,打开 Charles 抓包工具(Charles抓包工具可在历史文章中找到)，重新访问登录页面.</p>
<p>这是登录页面的Request数据:<br><img src="http://115.28.132.58:8080/docs/BLReq.png" alt=""><br>当然一眼看上去并没有什么可用数据。其实确实是没什么卵用的数据.那么我们来看看Response数据:<br><img src="http://115.28.132.58:8080/docs/BLRes.png" alt=""><br>一眼看上去是挺乱的。细看下它的Raw数据。其中包括了使用的Server、Set-Cookie等等的数据，还有登录页面的html文本. 那么其中最重要的数据也就是 Set-Cookie，这个Set-Cookie中的数据就是之前讲到的 用来和验证码绑定的唯一标示。那么我们来确认下，来看看验证码图片的包:<br><img src="http://115.28.132.58:8080/docs/BLCap.png" alt=""><br>快看，快看 验证码 Request 中的 Cookie，果然是上面登录页面的 Response 的 Set-Cookie。</p>
<p>那么验证码就简单了，我们通过代码来访问 B站 的登录页面，并拿到Response的Set-Cookie，然后再将这个Set-Cookie放到下载验证码Request的Cookie中，就这样，我们的验证码搞定了，那是不是登录就很简单了，少年憋急。登录才是大头..</p>
<p>来来来，基于上面的登录页面，我们在里面输入自己的账号，并完成登录来看看发的包都有哪些.</p>
<p>登录操作之后的Request:<br><img src="http://115.28.132.58:8080/docs/BLDolog.png" alt=""><br>可以看出来这是一个 post 请求，当然 Cookie 和验证码的一样将之前保存下来的 Set-Cookie 传给Request的Cookie.</p>
<p>post 参数如下:<br><img src="http://115.28.132.58:8080/docs/BLOnLogForm.png" alt=""><br>Orz,WTF，提交的密码加密了。那么我就需要来找一下它的加密算法了。其实网页端的加密并没有什么卵用。对我来说，就是随便翻翻代码的事（毕竟我很帅）。</p>
<p>来来来，找啊找啊找加密。然后我们先试探性的搜索下请求的字段 ‘pwd’ 如下图:<br><img src="http://115.28.132.58:8080/docs/SeachPwd.png" alt=""><br>果然定位到了加密的位置，当然前端页面的加密大部分都是很容易找到的，只要你有耐心.<br><img src="http://115.28.132.58:8080/docs/BLEncPwd.png" alt=""><br>以上就是 B站 加密密码的算法。简单讲下就是：通过 /login?act=getkey 拿到一个数据(hash,key),并以key作为RSA算法的公钥来加密 (hash+明文密码),然后针对这个数据来一次base64即可</p>
<p>python实现如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> rsa</div><div class="line">pub = rsa.PublicKey.load_pkcs1_openssl_pem(_key)</div><div class="line">_pwd = rsa.encrypt((_hash + psw).encode(),pub)</div><div class="line">_real_pwd = base64.b64encode(str(_pwd))</div></pre></td></tr></table></figure>
<p>那么现在我们就需要把问题聚焦到 /login?act=getkey 这个接口上。那么我们再回到之前的抓包数据上，会发现果然有一个 getkey 的请求:<br><img src="http://115.28.132.58:8080/docs/BLGetKey.png" alt=""><br>同上，Cookie是最开始的Set-Cookie。<br><img src="http://115.28.132.58:8080/docs/BLGetKeyRes.png" alt=""><br>Response中也就同时拿到了我们需要的 hash 和 key.大功告成，所有请求和加密都被我们搞定。</p>
<p>这时候我们再思考下登录脚本应该怎么判断是否登录成功呢，回头过来看下之前的登录操作的结果 也就是 上面的 dologin 接口.<br><img src="http://115.28.132.58:8080/docs/BLogLocation.png" alt=""><br>会发现如果你成功登录之后，在 dologin 接口上会有 302 重定向跳转，并最终跳转到 主页上。因此这时候我们就可以来写代码，模拟登录，并且在最后一步登录请求中判断当前请求历史的第一个状态码是不是 302 ，如果是302，说明我们的登录脚本是没问题的。同时，再拿到 dologin的Response中的Set-Cookie作为新的Cookie，因为这个Cookie才是真正验证通过的Cookie，当然它是存在有效期的。具体多少我还不清楚，一般有一个礼拜、一个月、甚至一年之久。之后我们用这个Cookie去做其他有意义的事情，是完全没问题的。</p>
<p>其次就是上传视频接口，也是类似的方法，需要分析上传视频的接口数据。并将最终的Cookie携带到请求包中。其中需要注意的是B站的上传视频可简单的分为以下几个步骤：</p>
<ol>
<li>将视频以Chunk的方式，而且是options的请求方式上传到服务器。因此它是支持断点续传的。</li>
<li>拿到options请求之后的视频id，再请求 add 接口将数据post上去即可</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然这篇文章很短，但是当你真正坐下来分析的时候，将是一段非常枯燥的过程。需要的就是你的耐心。</p>
<p>其次之所以写这篇文章，其实重点不是怎么去破解B站的登录，而是这些破解的逻辑是否可以提供给我们一些服务器架构的思路，抑或防范别人的破解。</p>
]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>https://xiyoumc.github.com/2017/03/17/Untitled/</url>
      <content type="html"><![CDATA[<p>   前段时间花了点功夫研究了下Django框架，也就是Python后端+Web端的开发框架，可以快速完成服务端的搭建.<br>借用 <code>Django</code> 官网的一句话 - “Django makes it easier to build better Web apps more quickly and with less code.”</p>
<p>   然后这两天又抽空翻了下之前自己做的Hybrid，然后顺其自然的我使用Django框架和Hybrid框架做了个简单的 Demo,并将其放到了Github上。有兴趣的朋友可以共同探讨下。</p>
<p>   地址在这: <a href="https://github.com/xiyouMc/HybridFramework" target="_blank" rel="external">https://github.com/xiyouMc/HybridFramework</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Google Hacking --你真的会用Google吗？]]></title>
      <url>https://xiyoumc.github.com/2017/03/16/Google%20Hacking%20--%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8Google%E5%90%97%EF%BC%9F/</url>
      <content type="html"><![CDATA[<h2 id="你真的会用Google吗？Google-Hacking提升工作效率"><a href="#你真的会用Google吗？Google-Hacking提升工作效率" class="headerlink" title="你真的会用Google吗？Google Hacking提升工作效率"></a>你真的会用Google吗？Google Hacking提升工作效率</h2><blockquote>
<p>阅读本文需要6.66分钟</p>
</blockquote>
<a id="more"></a>
<p>Google hacking，也叫作google dorking。如果在 Google 上搜索 <code>GoogleHack</code>,你会发现很多文章都是零几年的。所以已经不是陌生词了。</p>
<ul>
<li>简介</li>
<li>语法</li>
<li>具体应用和示例</li>
</ul>
<h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00. 简介"></a>0x00. 简介</h2><p> GoogleHack,旨在使用Google搜索引擎或者其他Google应用程序通过特定语法来查找网站配置或代码中的安全漏洞。</p>
<h2 id="0x01-语法"><a href="#0x01-语法" class="headerlink" title="0x01. 语法"></a>0x01. 语法</h2><blockquote>
<p>基本语法: operator:search_term</p>
</blockquote>
<p>其中以 all 开头的操作符在一般情况下一个查询中只能使用一次，不能与其他操作符混用.</p>
<ul>
<li><p>intext:</p>
<p>  可以指定网页内容中的关键字作为搜索条件,并且冒号后面只能跟一个关键词。如 Google 搜索： <code>intext:爬虫</code> 那么将返回所有包含 “爬虫” 的网页,同时也可以与其他操作符混用。</p>
</li>
<li><p>allintext:</p>
<p>  类似于 <code>intext:</code> ，能接多个关键词，不可以与其他操作符混用。</p>
</li>
<li><p>intitle:</p>
<p>  搜索标题中包含关键字的网页。如 Google搜索: <code>intitle:DeveloperPython</code>,那么搜索出来的将都是标题中包含 <code>DeveloperPython</code>的网页。</p>
</li>
<li><p>allintitle:</p>
<p>  同 <code>intitle:</code>,可接多个关键字，但不能和其他其他操作符混用。</p>
</li>
<li><p>cache:</p>
<p>  输入URL，搜索特定网页的缓存快照，即使页面发生了变动甚至不存在了，依然能看到它的副本。</p>
</li>
<li><p>define:</p>
<p>  搜索关键词的定义来源。如 Google搜索: <code>define:java</code>，那么将返回关于<code>python</code>的定义，不能与其他操作符混用</p>
</li>
<li><p>filetype:</p>
<p>  搜索指定类型的文件。 如 Google搜索： <code>filetype:txt</code>，那么将返回以 <code>txt</code> 结尾的文件URL，可以与其他操作符混用.</p>
</li>
<li><p>ext:</p>
<p>  同filetype</p>
</li>
<li><p>info:</p>
<p>  搜索到指定URL的摘要信息和其他相关信息,如 Google搜索： <code>info:facebook.com</code>，就会放回facebook的相关信息。不能与其他操作符混用。</p>
</li>
<li><p>inurl:</p>
<p>  搜索URL中包含指定关键字的网站。一般与site联合指定来找后台、管理等之类的页面，可以与其他操作符混用。</p>
</li>
<li><p>allinurl:</p>
<p>  同 <code>inurl:</code>,可接多个关键字。不能与其他操作符混用。</p>
</li>
<li><p>link:</p>
<p>  可搜索到链接到该URL的页面。如 Google搜索: <code>link:www.xiyoumobile.com</code> ，就会返回所有链接到该网站的页面。</p>
</li>
<li><p>site:</p>
<p>  可以指定网站、域或者子域，将搜索范围缩小。</p>
</li>
<li><p>related:</p>
<p>  搜索与该URL相关的页面。 如 Google搜索： ‘related:www.baidu.com’</p>
</li>
<li><p>inanchor:</p>
<p>  搜索一个HTML标记中的一个链接的文本表现形式。即在链接文本中搜索冒号后面紧接的一个关键词。</p>
<p>  至于“链接文本”，比如<br>  <code>&lt;a href=&quot;GNU/Linuxhttp://www.linux.org/&quot;&gt;GNU/Linux&lt;/a&gt;</code></p>
<p>  以上代码中的“GNU/Linux”就是链接文本</p>
</li>
<li><p>stocks:</p>
<p>  搜索指定公司的股票市场信息</p>
</li>
</ul>
<h2 id="0x03-具体应用和示例"><a href="#0x03-具体应用和示例" class="headerlink" title="0x03. 具体应用和示例"></a>0x03. 具体应用和示例</h2><h3 id="A-基础网站爬取（site-）"><a href="#A-基础网站爬取（site-）" class="headerlink" title="A.基础网站爬取（site:）"></a>A.基础网站爬取（site:）</h3><p><code>site:</code>旨在将搜索范围缩小到指定的网站、域或子域，如下：</p>
<p><code>site:facebook.com</code></p>
<p> <img src="http://115.28.132.58:8080/docs/site_facebook.png" alt=""></p>
<p> 一般我们剔除一些无意义的干扰网站，这时候就需要使用到 <code>负搜索</code>.</p>
<p> <code>site:facebook.com -site:www.facebook.com</code><br> <img src="http://115.28.132.58:8080/docs/fu_site_facebook.png" alt=""></p>
<p> 在这里我推荐一个终端浏览器 <code>lynx</code> ，玩Linux的应该很清楚这个。</p>
<p> 关于 <code>lynx</code> 的简介，这里有篇文章: <a href="http://linux.ximizi.com/linux/linux3298.htm" target="_blank" rel="external">http://linux.ximizi.com/linux/linux3298.htm</a></p>
<p> 如下，可通过 <code>lynx</code> 来代替我们手动在Google搜索引擎中做的操作：</p>
<p> dump这些操作符的结果<br> <img src="http://115.28.132.58:8080/docs/lynx_facebook.png" alt=""></p>
<p> 然后我们通过正则拿到我们想要的链接:</p>
<p>  <img src="http://115.28.132.58:8080/docs/sort_facebook.png" alt=""></p>
<h3 id="B-端口扫描"><a href="#B-端口扫描" class="headerlink" title="B. 端口扫描"></a>B. 端口扫描</h3><p> 可使用 <code>inurl:</code>结合 ‘intext:’</p>
<p> 如下：</p>
<p><img src="http://115.28.132.58:8080/docs/inurl_8080.png" alt=""></p>
<p> 这里分享一个端口扫描的工具 <code>Network Query Tool</code> 简称 <code>nqt</code>.</p>
<p> 我们通过 GoogleHack 来找到这个工具:</p>
<p><img src="http://115.28.132.58:8080/docs/nqt.png" alt=""></p>
<p> 打开第一个:</p>
<p><img src="http://115.28.132.58:8080/docs/nqt_site.png" alt=""></p>
<h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04. 总结"></a>0x04. 总结</h2><p>如上面例子，我们正确的使用Google，不仅能帮我们快速找到所需要的文章、电影、各种种子、*V等等的，并且还能针对我们的渗透测试省时省力。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python新手引导第二篇]]></title>
      <url>https://xiyoumc.github.com/2017/03/09/Python%E6%96%B0%E6%89%8B%E5%BC%95%E5%AF%BC%20%E7%AC%AC%E5%9B%9B%E7%AF%87/</url>
      <content type="html"><![CDATA[<h1 id="Python新手引导-第四篇"><a href="#Python新手引导-第四篇" class="headerlink" title="Python新手引导 第四篇"></a>Python新手引导 第四篇</h1><blockquote>
<p>###阅读本文需要4.66分钟</p>
</blockquote>
<a id="more"></a>
<p>之后的引导将以例子入手，作为一个程序员，我相信你从例子入手的话会更快的掌握一门语言。</p>
<ol>
<li>条件判断、循环、dict和set</li>
<li>函数</li>
<li>列表生成式<br>update order_pay_num set content = ‘支付一次，永久免费使用’<h2 id="第一、条件判断、循环、dict和set"><a href="#第一、条件判断、循环、dict和set" class="headerlink" title="第一、条件判断、循环、dict和set"></a>第一、条件判断、循环、dict和set</h2></li>
</ol>
<h3 id="1-1-条件判断"><a href="#1-1-条件判断" class="headerlink" title="1.1 条件判断"></a>1.1 条件判断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding:utf-8</span></div><div class="line">age = input(<span class="string">'input num:'</span>)</div><div class="line"><span class="keyword">if</span> age &gt; <span class="number">18</span>:</div><div class="line">	print(<span class="string">'age 大于 18'</span>)</div><div class="line"><span class="keyword">elif</span> age &gt; <span class="number">11</span> <span class="keyword">and</span> age &lt; <span class="number">18</span>:</div><div class="line">	print(<span class="string">'age 大于11 并小于18'</span>)</div><div class="line"><span class="keyword">else</span> :</div><div class="line">	print(<span class="string">'其他'</span>)</div></pre></td></tr></table></figure>
<p>如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> &lt;条件判断<span class="number">1</span>&gt;:</div><div class="line">    &lt;执行<span class="number">1</span>&gt;</div><div class="line"><span class="keyword">elif</span> &lt;条件判断<span class="number">2</span>&gt;:</div><div class="line">    &lt;执行<span class="number">2</span>&gt;</div><div class="line"><span class="keyword">elif</span> &lt;条件判断<span class="number">3</span>&gt;:</div><div class="line">    &lt;执行<span class="number">3</span>&gt;</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    &lt;执行<span class="number">4</span>&gt;</div></pre></td></tr></table></figure>
<p>其中<code>input()</code>:<br>2.x 下 <code>input</code>读取的内容和输入的一样的。 但在3.x以上 读取的都是字符串，这一点大家要和<code>raw_input()</code>做区分</p>
<h3 id="1-2-循环"><a href="#1-2-循环" class="headerlink" title="1.2 循环"></a>1.2 循环</h3><h4 id="1-2-1-for-in"><a href="#1-2-1-for-in" class="headerlink" title="1.2.1 for in"></a>1.2.1 <code>for in</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">names = [<span class="string">'Mark'</span>,<span class="string">'Alison'</span>]</div><div class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</div><div class="line">	print(name)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for &lt;元素&gt; in &lt;集合&gt;：</div></pre></td></tr></table></figure>
<p>在这里给大家讲一下 <code>range()</code>，rangek可以生成对应参数的n个整数。如： <code>range(100)</code>,就会生成0 到 100的整数。因此在遍历list的时候也可以这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">names = [<span class="string">'Mark'</span>,<span class="string">'Alison'</span>]</div><div class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(len(names)):</div><div class="line">	print(names[index])</div></pre></td></tr></table></figure>
<h4 id="1-2-2-while"><a href="#1-2-2-while" class="headerlink" title="1.2.2 while"></a>1.2.2 <code>while</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sum = <span class="number">0</span></div><div class="line">n = <span class="number">99</span></div><div class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</div><div class="line">	sum = sum + n</div><div class="line">	n = n <span class="number">-2</span></div><div class="line">print(sum)</div></pre></td></tr></table></figure>
<h3 id="1-3-集合"><a href="#1-3-集合" class="headerlink" title="1.3 集合"></a>1.3 集合</h3><h4 id="1-3-1-dict"><a href="#1-3-1-dict" class="headerlink" title="1.3.1 dict"></a>1.3.1 dict</h4><blockquote>
<p>Python中内置的字典。在其他语言中是 map之类的 (key-value)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>names = &#123;<span class="string">'Mark'</span>:<span class="string">'18'</span>,<span class="string">'Alison'</span>:<span class="string">'18'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>names</div><div class="line">&#123;<span class="string">'Alison'</span>: <span class="string">'18'</span>, <span class="string">'Mark'</span>: <span class="string">'18'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>names[<span class="string">'Mark'</span>]</div><div class="line"><span class="string">'18'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>names[<span class="string">'Jordan'</span>] = <span class="string">'88'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>names</div><div class="line">&#123;<span class="string">'Jordan'</span>: <span class="string">'88'</span>, <span class="string">'Alison'</span>: <span class="string">'18'</span>, <span class="string">'Mark'</span>: <span class="string">'18'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>names.get(<span class="string">'Ali'</span>,<span class="string">'-1'</span>) <span class="comment">#get方法可指定默认值，若这个key不存在，返回默认值</span></div><div class="line"><span class="string">'-1'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>names.pop(<span class="string">'Jordan'</span>) <span class="comment">#Pop出栈</span></div><div class="line"><span class="string">'88'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>names</div><div class="line">&#123;<span class="string">'Alison'</span>: <span class="string">'18'</span>, <span class="string">'Mark'</span>: <span class="string">'18'</span>&#125;</div></pre></td></tr></table></figure>
<p>dict适用于需要高速查找的地方。</p>
<h4 id="1-3-2-set"><a href="#1-3-2-set" class="headerlink" title="1.3.2 set"></a>1.3.2 set</h4><blockquote>
<p>一组不包含value的  key集合，并且不能重复。入参是 list</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.add(<span class="number">5</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.remove(<span class="number">5</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div></pre></td></tr></table></figure>
<p>切记关于<code>key</code>的都是不可变的。因为存储的时候，是通过计算key的hash来做的。</p>
<h2 id="第二、函数"><a href="#第二、函数" class="headerlink" title="第二、函数"></a>第二、函数</h2><h3 id="2-1-内置函数"><a href="#2-1-内置函数" class="headerlink" title="2.1 内置函数"></a>2.1 内置函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="number">1.2</span>) <span class="comment"># 求绝对值</span></div><div class="line"><span class="number">1.2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="number">-1</span>)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'1'</span>) <span class="comment"># 将str的转换为int</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="number">1</span>) <span class="comment"># 将int转换为str</span></div><div class="line"><span class="string">'1'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="number">1</span>) <span class="comment"># 转换bool值</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="string">''</span>)</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<h3 id="2-2-定义函数"><a href="#2-2-定义函数" class="headerlink" title="2.2 定义函数"></a>2.2 定义函数</h3><blockquote>
<p>Python中使用<code>def</code>定义函数，并可通过 <code>return</code>来返回值</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">myAbs</span><span class="params">(x)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">if</span> x &gt; <span class="number">0</span>:</div><div class="line"><span class="meta">... </span>            <span class="keyword">return</span> x</div><div class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</div><div class="line"><span class="meta">... </span>            <span class="keyword">return</span> -x</div><div class="line">...</div><div class="line">&gt;&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>myAbs(<span class="number">1</span>)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>myAbs(<span class="number">-1</span>)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>myAbs(<span class="number">-2</span>)</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>其中 <code>return</code>表示函数执行的终止，并将结果返回。<br>需要注意的是 <code>return None</code>可直接用 <code>return</code>表示</p>
<h4 id="2-2-1-空函数"><a href="#2-2-1-空函数" class="headerlink" title="2.2.1 空函数"></a>2.2.1 空函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">nop</span><span class="params">()</span>:</span></div><div class="line">	<span class="keyword">pass</span> <span class="comment">#可作为占位符，表示还没想好写什么</span></div></pre></td></tr></table></figure>
<h4 id="2-2-2-返回多个值"><a href="#2-2-2-返回多个值" class="headerlink" title="2.2.2 返回多个值"></a>2.2.2 返回多个值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></div><div class="line">	<span class="keyword">return</span> <span class="string">'1'</span>,<span class="string">'2'</span></div><div class="line">a,b = fun()</div></pre></td></tr></table></figure>
<p>这个还是比较方便的。 不用我们再继续封装起来返回，唯一恶心的就是得约定好规则。</p>
<p>其实这返回不是两个值，而是一个tuple，这个得理解下</p>
<h4 id="2-2-3-默认参数"><a href="#2-2-3-默认参数" class="headerlink" title="2.2.3 默认参数"></a>2.2.3 默认参数</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def fun(a,b=2)</div><div class="line">	print a,b</div></pre></td></tr></table></figure>
<p>其中b的默认值是2</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def fun(L=[])</div><div class="line">	L.append('End')</div><div class="line">	return L</div></pre></td></tr></table></figure>
<p>传一个list，并添加 <code>End</code>再返回。其中要注意的是，python会记住append的元素。意思就是：如果你多次调用 fun() ，会发现 之后的元素都是 <code>End</code></p>
<p>因此这种传递List的方式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(L=None)</span>:</span></div><div class="line">	<span class="keyword">if</span> L <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">		L = []</div><div class="line">	L.append(<span class="string">'End'</span>)</div><div class="line">	<span class="keyword">return</span> L</div></pre></td></tr></table></figure>
<h4 id="2-2-4-可变参数，使用"><a href="#2-2-4-可变参数，使用" class="headerlink" title="2.2.4 可变参数，使用 *"></a>2.2.4 可变参数，使用 <code>*</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(*n)</span>:</span></div><div class="line">	sum = <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> num <span class="keyword">in</span> n:</div><div class="line">		sum +=num</div><div class="line">	<span class="keyword">return</span> sum</div><div class="line">addNum(*nums)</div></pre></td></tr></table></figure>
<p>*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。</p>
<h4 id="2-2-5-关键字参数"><a href="#2-2-5-关键字参数" class="headerlink" title="2.2.5 关键字参数 **"></a>2.2.5 关键字参数 <code>**</code></h4><p>表示允许传入0个或者任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></div><div class="line">    print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Michael'</span>, <span class="number">30</span>)</div><div class="line">name: Michael age: <span class="number">30</span> other: &#123;&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Bob'</span>, <span class="number">35</span>, city=<span class="string">'Beijing'</span>)</div><div class="line">name: Bob age: <span class="number">35</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Adam'</span>, <span class="number">45</span>, gender=<span class="string">'M'</span>, job=<span class="string">'Engineer'</span>)</div><div class="line">name: Adam age: <span class="number">45</span> other: &#123;<span class="string">'gender'</span>: <span class="string">'M'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</div></pre></td></tr></table></figure>
<p>和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>extra = &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=extra[<span class="string">'city'</span>], job=extra[<span class="string">'job'</span>])</div><div class="line">name: Jack age: <span class="number">24</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>extra = &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, **extra)</div><div class="line">name: Jack age: <span class="number">24</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</div></pre></td></tr></table></figure>
<h4 id="2-2-6-命名关键字参数"><a href="#2-2-6-命名关键字参数" class="headerlink" title="2.2.6 命名关键字参数"></a>2.2.6 命名关键字参数</h4><p>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。</p>
<p>仍以person()函数为例，我们希望检查是否有city和job参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="string">'city'</span> <span class="keyword">in</span> kw:</div><div class="line">        <span class="comment"># 有city参数</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="keyword">if</span> <span class="string">'job'</span> <span class="keyword">in</span> kw:</div><div class="line">        <span class="comment"># 有job参数</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</div></pre></td></tr></table></figure>
<p>但是调用者仍可以传入不受限制的关键字参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=<span class="string">'Beijing'</span>, addr=<span class="string">'Chaoyang'</span>, zipcode=<span class="number">123456</span>)</div></pre></td></tr></table></figure>
<p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city, job)</span>:</span></div><div class="line">    print(name, age, city, job)</div></pre></td></tr></table></figure>
<p>和关键字参数<em>*kw不同，命名关键字参数需要一个特殊分隔符</em>，*后面的参数被视为命名关键字参数。</p>
<p>调用方式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Mark'</span>, <span class="number">24</span>, city=<span class="string">'hangzhou'</span>, job=<span class="string">'Engineer'</span>)</div><div class="line">Mark <span class="number">24</span> hangzhou Engineer</div></pre></td></tr></table></figure>
<h2 id="第三、列表生成式"><a href="#第三、列表生成式" class="headerlink" title="第三、列表生成式"></a>第三、列表生成式</h2><blockquote>
<p>List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式</p>
</blockquote>
<p>举例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>[x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>)]</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>]</div><div class="line">[<span class="string">'AX'</span>, <span class="string">'AY'</span>, <span class="string">'AZ'</span>, <span class="string">'BX'</span>, <span class="string">'BY'</span>, <span class="string">'BZ'</span>, <span class="string">'CX'</span>, <span class="string">'CY'</span>, <span class="string">'CZ'</span>]</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'x'</span>: <span class="string">'A'</span>, <span class="string">'y'</span>: <span class="string">'B'</span>, <span class="string">'z'</span>: <span class="string">'C'</span> &#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</div><div class="line"><span class="meta">... </span>    print(k, <span class="string">'='</span>, v)</div><div class="line">...</div><div class="line">y = B</div><div class="line">x = A</div><div class="line">z = C</div></pre></td></tr></table></figure>
<h2 id="第四、生成器-generator"><a href="#第四、生成器-generator" class="headerlink" title="第四、生成器 generator"></a>第四、生成器 generator</h2><blockquote>
<p>如名字，其就是一个生成我们所需数据的容器，而不像 列表生成式，计算出所有数据。因此节省了空间，也解决了时间</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>g</div><div class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x1022ef630</span>&gt;</div></pre></td></tr></table></figure>
<p> 遍历: next(g)</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> g:</div><div class="line"><span class="meta">... </span>    print(n)</div><div class="line"><span class="meta">... </span></div><div class="line"><span class="number">0</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">9</span></div><div class="line"><span class="number">16</span></div><div class="line"><span class="number">25</span></div><div class="line"><span class="number">36</span></div><div class="line"><span class="number">49</span></div><div class="line"><span class="number">64</span></div><div class="line"><span class="number">81</span></div></pre></td></tr></table></figure>
<p> <code>yeild</code>可中断当前操作，使函数成为 生成器 而不是普通函数</p>
<p>举例： 杨慧三角</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">         <span class="number">1</span></div><div class="line">        <span class="number">1</span>   <span class="number">1</span></div><div class="line">      <span class="number">1</span>   <span class="number">2</span>   <span class="number">1</span></div><div class="line">    <span class="number">1</span>   <span class="number">3</span>   <span class="number">3</span>   <span class="number">1</span></div><div class="line">  <span class="number">1</span>   <span class="number">4</span>   <span class="number">6</span>   <span class="number">4</span>   <span class="number">1</span></div><div class="line"><span class="number">1</span>   <span class="number">5</span>   <span class="number">10</span>  <span class="number">10</span>  <span class="number">5</span>   <span class="number">1</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">yanghu</span><span class="params">(n)</span>:</span></div><div class="line">	L=[<span class="number">1</span>]</div><div class="line">	<span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">		yeild L</div><div class="line">		L = [L[x] + L[x+<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> range(len(L) <span class="number">-1</span>)]</div><div class="line">		L.insert(<span class="number">0</span>,<span class="number">1</span>)</div><div class="line">		L.append(<span class="number">1</span>)</div><div class="line">		<span class="keyword">if</span> len(L)&gt;n:</div><div class="line">			<span class="keyword">break</span></div><div class="line"><span class="keyword">for</span> n <span class="keyword">in</span> yanghu(<span class="number">10</span>):</div><div class="line">	<span class="keyword">print</span> n</div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇用一些简单的例子来讲解了下基础知识。 多动手练练哦</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python新手引导第二篇]]></title>
      <url>https://xiyoumc.github.com/2017/03/06/Python%E6%96%B0%E6%89%8B%E5%BC%95%E5%AF%BC%20%E7%AC%AC%E4%B8%89%E7%AF%87%20Python%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h1 id="Python新手引导-第三篇-Python基础和字符编码"><a href="#Python新手引导-第三篇-Python基础和字符编码" class="headerlink" title="Python新手引导 第三篇-Python基础和字符编码"></a>Python新手引导 第三篇-Python基础和字符编码</h1><blockquote>
<p>###阅读本文需要4.66分钟</p>
</blockquote>
<a id="more"></a>
<p>有其他计算机语言基础的同学，阅读本篇基础部分建议1到2分钟。</p>
<ol>
<li>基础类型、变量和字符编码</li>
<li>list 和 tuple</li>
</ol>
<h2 id="第一、基础类型、变量和字符编码"><a href="#第一、基础类型、变量和字符编码" class="headerlink" title="第一、基础类型、变量和字符编码"></a>第一、基础类型、变量和字符编码</h2><blockquote>
<p>计算机能处理的数据类型有很多，包括文本、图形、音频、视频等等的。上层语言对其不同的数据，定义了各自不同的数据类型。如Java的int、String、boolean，JS的var等等的。Python也不例外：</p>
</blockquote>
<h3 id="1-1-基础类型"><a href="#1-1-基础类型" class="headerlink" title="1.1 基础类型"></a>1.1 基础类型</h3><ol>
<li><p>整数</p>
<p>  Python可以处理任意大小的整数，包括负整数。1、100、-9191等等。</p>
</li>
<li><p>浮点数</p>
<p>   浮点数也就是小数。之所以称之为浮点数。是因为其小数点是可变的，比如：1.23x10^5 和12.3x10^4是一样的。也就是类似的科学计数法 1.23e5和12.3e4。因此浮点数在计算机存储的时候可能就会有四舍五入的情况</p>
</li>
<li><p>字符串</p>
<p>   ‘ 或者 “括起来的任意文本</p>
</li>
<li><p>布尔值</p>
<p> True和False, 同时可以使用<code>and</code> <code>or</code> <code>not</code>来运算</p>
</li>
<li><p>空值 Python中使用<code>None</code>来表示空值，其不是<code>0</code>的意义</p>
</li>
</ol>
<h3 id="1-2-变量"><a href="#1-2-变量" class="headerlink" title="1.2 变量"></a>1.2 变量</h3><blockquote>
<p>变量在程序中就是用一个变量名标书，且区分大小写，可用<code>数字</code>和<code>_</code>表示，并不能以数字开始</p>
</blockquote>
<h4 id="a-‘aaa’"><a href="#a-‘aaa’" class="headerlink" title="a = ‘aaa’"></a>a = ‘aaa’</h4><ul>
<li>Python解释器会在内存中创建<code>aaa</code>的字符串</li>
<li>并在内存中创建一个名为<code>a</code>的变量，并将其指向<code>aaa</code></li>
</ul>
<h3 id="1-3-字符编码"><a href="#1-3-字符编码" class="headerlink" title="1.3 字符编码"></a>1.3 字符编码</h3><blockquote>
<p>最原始的由歪果仁定义的<code>ASCII</code>编码，使用127个字符，从A(65)到z(122). 其次就是各国的编码，如我们所知的<code>GB2312</code>将中文编进去。还有其他国家的类似，日本的<code>Shift_JIS</code>等等。如此一来，你会发现各国都有自己的编码，那么岂不是各种乱码。<br>因此<code>Unicode</code>就因此诞生了。<code>Unicode</code>将所有编码统一到了一套编码中，这样就解决了乱码的问题。</p>
</blockquote>
<p>Unicode和ASCII编码的区别：Unicdeo使用两个字节、ASCII使用一个字节</p>
<ul>
<li>举个栗子</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>ASCII</th>
<th>Unicode</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>十进制（65）,二进制(01000001)</td>
<td>0A (00000000 01000001)</td>
</tr>
</tbody>
</table>
<p> 因此你会发现如果你的文本全是英文的，使用Unicode编码的话，那么需要多一倍的存储空间，导致存储和传输上十分低效率。</p>
<p><code>UTF_8</code>应景而生，是一种<code>可变长编码</code>.<code>UTF_8</code>编码把一个Unicode字符根据不同的数组大小编码成1-6个字节，常用的英文被编码成1个字节，汉字使用3个字节。如果要传输的文本包含大量的英文字符，用UTF-8编码能节省很多空间：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>ASCII</th>
<th>Unicode</th>
<th>UTF-8</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>十进制（65）,二进制(01000001)</td>
<td>0A (00000000 01000001)</td>
<td>01000001</td>
</tr>
<tr>
<td>中</td>
<td></td>
<td>01001110 00101101</td>
<td>11100100 10111000 10101101</td>
</tr>
</tbody>
</table>
<p>所以在计算机的内存中，统一使用Unicode编码，但是需要保存到硬盘或者传输的时候，就会使用到UTF-8编码。因此在计算机上打开某个文本的时候，会首先以Unicode将其独到内存中，当修改保存的时候，又会使用UTF-8。</p>
<p>使用Unicode表示的<code>str</code>可以通过encode()转换为指定的<code>bytes</code>,例如：</p>
<ul>
<li><blockquote>
<blockquote>
<blockquote>
<p>‘A’.encode(‘ascii’)</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>b’A’</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>b’\xe4\xb8\xad\xe6\x96\x87’.decode(‘utf-8’)</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>‘中文’</li>
</ul>
<p><code>len()</code>可计算<code>str</code>包含多少个字符,len(‘abc’) = 3</p>
<p>在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。</p>
<p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div></pre></td></tr></table></figure>
<h2 id="第二、List和tuple"><a href="#第二、List和tuple" class="headerlink" title="第二、List和tuple"></a>第二、List和tuple</h2><blockquote>
<p>集合在每个语言中都有，当然Python也不例外。</p>
</blockquote>
<h3 id="2-1-List"><a href="#2-1-List" class="headerlink" title="2.1 List"></a>2.1 List</h3><p>Python内置的列表数据类型。一种有序的集合，可随时添加和删除其中元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name = [&apos;Mark&apos;,&apos;xiyouMc&apos;,&apos;Alison&apos;]</div></pre></td></tr></table></figure></p>
<p>访问方式可直接通过索引: <code>name[0]</code> <code>name[1]</code> 当然索引是从<code>0</code>开始到<code>len(name) - 1</code>  区别去其他语言，Python可以通过 <code>name[-1]</code>访问到最后一个元素，一次类推 <code>-2</code>可以访问到倒数第二个。</p>
<p>list是一个可变的有序表，所以可以在list的末尾追加元素: <code>name.append(&#39;Ali&#39;)</code></p>
<p>同样也可以插入元素, <code>name.insert(1,&#39;Baidu&#39;)</code></p>
<p>删除尾部元素使用<code>pop()</code>,并可以指定删除某个元素 <code>pop(1)</code></p>
<p>赋值（替换）： <code>name[1] = &#39;Tencent&#39;</code></p>
<p>多层List：<code>s = [&#39;Mark&#39;,&#39;java&#39;,[&#39;nlp&#39;,&#39;php&#39;]]</code>,这样通过 <code>s[2]</code>拿到的也是一个list. 当然要拿到 <code>nlp</code>的话，直接<code>s[2][1]</code>即可</p>
<h3 id="2-2-tuple"><a href="#2-2-tuple" class="headerlink" title="2.2 tuple"></a>2.2 tuple</h3><blockquote>
<p>和List一样，tuple也是一个有序列表。唯一和list有区别的就是 tuple一旦被初始化就<code>不能修改</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name = (&apos;Mark&apos;,&apos;Alison&apos;,&apos;xiyouMc&apos;)</div></pre></td></tr></table></figure>
<p>即tuple没有 <code>append</code> <code>insert</code>函数。</p>
<p><code>a = (1,)</code>表示只有一个元素的tuple.</p>
<p>当然如果tuple中包含list那么这个list是可变的,因此tuple中保存的只是list的指针，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = (&apos;A&apos;,[&apos;B&apos;,&apos;C&apos;])</div><div class="line">a[1][1] = &apos;D&apos;</div><div class="line">(&apos;A&apos;,[&apos;D&apos;,&apos;C&apos;])</div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇主要讲了计算机的基础知识–编码，看过这篇文章之后，以后遇到乱码的问题，相信你不用再百度了。 其次就是Python中常用到的基础类型和集合，玩一玩吧…少年</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python新手引导第二篇]]></title>
      <url>https://xiyoumc.github.com/2017/03/06/Python%E6%96%B0%E6%89%8B%E5%BC%95%E5%AF%BC%E7%AC%AC%E4%B8%89%E7%AF%87/</url>
      <content type="html"><![CDATA[<h1 id="Python新手引导-第三篇-Python基础"><a href="#Python新手引导-第三篇-Python基础" class="headerlink" title="Python新手引导 第三篇 Python基础"></a>Python新手引导 第三篇 Python基础</h1><blockquote>
<p>###阅读本文需要4.66分钟</p>
</blockquote>
<a id="more"></a>
<p>有其他计算机语言基础的同学，阅读本篇基础部分建议1到2分钟。</p>
<ol>
<li>基础类型和变量</li>
<li>list 和 tuple</li>
</ol>
<h2 id="第一、基础类型和变量"><a href="#第一、基础类型和变量" class="headerlink" title="第一、基础类型和变量"></a>第一、基础类型和变量</h2><blockquote>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[程序员都应该会的抓包工具--Charles]]></title>
      <url>https://xiyoumc.github.com/2017/03/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BC%9A%E7%9A%84%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7-Charles/</url>
      <content type="html"><![CDATA[<h1 id="程序员都应该会的抓包工具-Charles"><a href="#程序员都应该会的抓包工具-Charles" class="headerlink" title="程序员都应该会的抓包工具-Charles"></a>程序员都应该会的抓包工具-Charles</h1><blockquote>
<h3 id="阅读本文需要7-66分钟"><a href="#阅读本文需要7-66分钟" class="headerlink" title="阅读本文需要7.66分钟"></a>阅读本文需要7.66分钟</h3></blockquote>
<a id="more"></a>
<h5 id="抓包-其实很多程序员都不陌生了，但是真正抓过包、分析过的又有几个。"><a href="#抓包-其实很多程序员都不陌生了，但是真正抓过包、分析过的又有几个。" class="headerlink" title="抓包 其实很多程序员都不陌生了，但是真正抓过包、分析过的又有几个。"></a><code>抓包</code> 其实很多程序员都不陌生了，但是真正抓过包、分析过的又有几个。</h5><h5 id="本文将介绍几款简单易用的抓包工具，并针对目前互联网主流的Http和Https网络包进行抓取并分析，同时分享手机抓包的技术"><a href="#本文将介绍几款简单易用的抓包工具，并针对目前互联网主流的Http和Https网络包进行抓取并分析，同时分享手机抓包的技术" class="headerlink" title="本文将介绍几款简单易用的抓包工具，并针对目前互联网主流的Http和Https网络包进行抓取并分析，同时分享手机抓包的技术"></a>本文将介绍几款简单易用的抓包工具，并针对目前互联网主流的Http和Https网络包进行抓取并分析，同时分享手机抓包的技术</h5><h5 id="1-Charles、Fiddler和Wireshark"><a href="#1-Charles、Fiddler和Wireshark" class="headerlink" title="1. Charles、Fiddler和Wireshark"></a>1. Charles、Fiddler和Wireshark</h5><h5 id="2-Http、Https及其原理"><a href="#2-Http、Https及其原理" class="headerlink" title="2. Http、Https及其原理"></a>2. Http、Https及其原理</h5><h5 id="3-手机抓包"><a href="#3-手机抓包" class="headerlink" title="3. 手机抓包"></a>3. 手机抓包</h5><h5 id="4-Charles的附加功能"><a href="#4-Charles的附加功能" class="headerlink" title="4. Charles的附加功能"></a>4. Charles的附加功能</h5><h2 id="一、抓包工具"><a href="#一、抓包工具" class="headerlink" title="一、抓包工具"></a>一、抓包工具</h2><ul>
<li><code>Fiddler</code><ul>
<li>是之前我用Window电脑的时候，特别喜欢用的工具，而且当时的Fiddler足以满足的我简单的抓包工作，现在也应该更新到Fiddler3了，如果用Windows的朋友可以用Fiddler3进行抓包。</li>
</ul>
</li>
<li><code>Charles</code><ul>
<li>自从换了Mac之后我就喜欢上了这个工具，不过Charles在Windows上同样也有。</li>
</ul>
</li>
<li><code>Wireshark</code><ul>
<li>这个我不是怎么经常用，这个抓包工具可以详细的看到网络请求的三次握手，并且可支持spdy、tcp等等的网络协议抓包，当然其他两个是不支持的。</li>
</ul>
</li>
</ul>
<p>我将以Charles为例分别抓取Http和Https包：</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><h5 id="Mac破解版下载地址：http-download-csdn-net-detail-m694449212-9770583"><a href="#Mac破解版下载地址：http-download-csdn-net-detail-m694449212-9770583" class="headerlink" title="Mac破解版下载地址：http://download.csdn.net/detail/m694449212/9770583"></a>Mac破解版下载地址：<a href="http://download.csdn.net/detail/m694449212/9770583" target="_blank" rel="external">http://download.csdn.net/detail/m694449212/9770583</a></h5><h5 id="Win破解版下载地址：http-download-csdn-net-detail-m694449212-9770589"><a href="#Win破解版下载地址：http-download-csdn-net-detail-m694449212-9770589" class="headerlink" title="Win破解版下载地址：http://download.csdn.net/detail/m694449212/9770589"></a>Win破解版下载地址：<a href="http://download.csdn.net/detail/m694449212/9770589" target="_blank" rel="external">http://download.csdn.net/detail/m694449212/9770589</a></h5><h5 id="官网链接，需要购买LisenseKey：https-www-charlesproxy-com"><a href="#官网链接，需要购买LisenseKey：https-www-charlesproxy-com" class="headerlink" title="官网链接，需要购买LisenseKey：https://www.charlesproxy.com/"></a>官网链接，需要购买LisenseKey：<a href="https://www.charlesproxy.com/" target="_blank" rel="external">https://www.charlesproxy.com/</a></h5><p><img src="http://115.28.132.58:8080/docs/WX20170304-233530@2x.png" alt=""></p>
<h5 id="打开界面如下："><a href="#打开界面如下：" class="headerlink" title="打开界面如下："></a>打开界面如下：</h5><p><img src="http://115.28.132.58:8080/docs/CharlesOpen.png" alt=""></p>
<h2 id="第二、Http、Https包"><a href="#第二、Http、Https包" class="headerlink" title="第二、Http、Https包"></a>第二、Http、Https包</h2><h3 id="2-1、Http包"><a href="#2-1、Http包" class="headerlink" title="2.1、Http包"></a>2.1、Http包</h3><h5 id="2-1-1-清理Charles列表，让抓包更加清晰"><a href="#2-1-1-清理Charles列表，让抓包更加清晰" class="headerlink" title="2.1.1 清理Charles列表，让抓包更加清晰"></a>2.1.1 清理Charles列表，让抓包更加清晰</h5><p><img src="http://115.28.132.58:8080/docs/CharlesClean.png" alt=""></p>
<h5 id="2-1-2-以我的CSDN为例（m694449212）-通过Chrome点击‘我的博客’，抓到需要的包"><a href="#2-1-2-以我的CSDN为例（m694449212）-通过Chrome点击‘我的博客’，抓到需要的包" class="headerlink" title="2.1.2 以我的CSDN为例（m694449212）,通过Chrome点击‘我的博客’，抓到需要的包"></a>2.1.2 以我的CSDN为例（m694449212）,通过Chrome点击‘我的博客’，抓到需要的包</h5><p><img src="http://115.28.132.58:8080/docs/CSDNBlog.png" alt=""></p>
<h5 id="从中我们过滤出m694449212的博客包，但是这个过滤的过程需要我们去一个个找（当然如果你的经验比较足或者英语比较好的话，可以发现其实就是blog-csdn-net的包）"><a href="#从中我们过滤出m694449212的博客包，但是这个过滤的过程需要我们去一个个找（当然如果你的经验比较足或者英语比较好的话，可以发现其实就是blog-csdn-net的包）" class="headerlink" title="从中我们过滤出m694449212的博客包，但是这个过滤的过程需要我们去一个个找（当然如果你的经验比较足或者英语比较好的话，可以发现其实就是blog.csdn.net的包）"></a>从中我们过滤出m694449212的博客包，但是这个过滤的过程需要我们去一个个找（当然如果你的经验比较足或者英语比较好的话，可以发现其实就是blog.csdn.net的包）</h5><h5 id="2-1-3-分析包"><a href="#2-1-3-分析包" class="headerlink" title="2.1.3 分析包"></a>2.1.3 分析包</h5><p><img src="http://115.28.132.58:8080/docs/CharlesCSDAnly.png" alt=""></p>
<h5 id="2-1-4-Reuqest"><a href="#2-1-4-Reuqest" class="headerlink" title="2.1.4 Reuqest"></a>2.1.4 Reuqest</h5><p><img src="http://115.28.132.58:8080/docs/CharlesRequest.png" alt=""></p>
<h5 id="其中比较重要的是Cookie-网站为了辨别用户身份、进行-session-跟踪而储存在用户本地终端上的数据（通常经过加密）"><a href="#其中比较重要的是Cookie-网站为了辨别用户身份、进行-session-跟踪而储存在用户本地终端上的数据（通常经过加密）" class="headerlink" title="其中比较重要的是Cookie,网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）."></a>其中比较重要的是<code>Cookie</code>,网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）.</h5><h5 id="同时Cookie在我们爬虫的时候也是一个必不可少的东西，那么如何自动化获取Cookie呢？后面会讲解到。"><a href="#同时Cookie在我们爬虫的时候也是一个必不可少的东西，那么如何自动化获取Cookie呢？后面会讲解到。" class="headerlink" title="同时Cookie在我们爬虫的时候也是一个必不可少的东西，那么如何自动化获取Cookie呢？后面会讲解到。"></a>同时Cookie在我们爬虫的时候也是一个必不可少的东西，那么如何自动化获取Cookie呢？后面会讲解到。</h5><h5 id="2-1-5-Response"><a href="#2-1-5-Response" class="headerlink" title="2.1.5 Response"></a>2.1.5 Response</h5><p><img src="http://115.28.132.58:8080/docs/CharlesResponse.png" alt=""></p>
<h5 id="获取Cookie-通过我以往的经验"><a href="#获取Cookie-通过我以往的经验" class="headerlink" title="获取Cookie,通过我以往的经验:"></a>获取Cookie,通过我以往的经验:</h5><h5 id="a-获取Cookie的时候首先需要保证我们的浏览器环境是干净的，我说的干净其实就是清楚当前浏览器保存的Cookie，并重启浏览器。"><a href="#a-获取Cookie的时候首先需要保证我们的浏览器环境是干净的，我说的干净其实就是清楚当前浏览器保存的Cookie，并重启浏览器。" class="headerlink" title="a. 获取Cookie的时候首先需要保证我们的浏览器环境是干净的，我说的干净其实就是清楚当前浏览器保存的Cookie，并重启浏览器。"></a>a. 获取Cookie的时候首先需要保证我们的浏览器环境是干净的，我说的干净其实就是<code>清楚当前浏览器保存的Cookie</code>，并重启浏览器。</h5><h5 id="b-重启之后我们访问www-csdn-net，当前Host的Request中就不包含Cookie，那么Cookie在哪呢，其实细心点的会发现Cookie在Response的Headers-gt-set-cookie中，并在下次请求中使用到。"><a href="#b-重启之后我们访问www-csdn-net，当前Host的Request中就不包含Cookie，那么Cookie在哪呢，其实细心点的会发现Cookie在Response的Headers-gt-set-cookie中，并在下次请求中使用到。" class="headerlink" title="b. 重启之后我们访问www.csdn.net，当前Host的Request中就不包含Cookie，那么Cookie在哪呢，其实细心点的会发现Cookie在Response的Headers-&gt;set-cookie中，并在下次请求中使用到。"></a>b. 重启之后我们访问www.csdn.net，当前Host的Request中就不包含Cookie，那么Cookie在哪呢，其实细心点的会发现Cookie在<code>Response的Headers-&gt;set-cookie</code>中，并在下次请求中使用到。</h5><h5 id="c-那么当我们登录操作并携带Cookie在请求Headers中，那么登录成功之后该Cookie就会生效。之后我们的所有请求携带该Cookie就会是一个正常的请求，并能拿到需要的结果。"><a href="#c-那么当我们登录操作并携带Cookie在请求Headers中，那么登录成功之后该Cookie就会生效。之后我们的所有请求携带该Cookie就会是一个正常的请求，并能拿到需要的结果。" class="headerlink" title="c. 那么当我们登录操作并携带Cookie在请求Headers中，那么登录成功之后该Cookie就会生效。之后我们的所有请求携带该Cookie就会是一个正常的请求，并能拿到需要的结果。"></a>c. 那么当我们登录操作并携带Cookie在请求Headers中，那么登录成功之后该Cookie就会生效。之后我们的所有请求携带该Cookie就会是一个正常的请求，并能拿到需要的结果。</h5><h5 id="关于某些请求携带sign参数的，后面的文章我会讲解到破解Sign函数（其实有时候不是直接的破解而是函数的Hook-有兴趣的可以提前了解下Android或者iOS的Hook，通过IDA找到sign函数-并使用cycript调用），之后的文章我会以国外的知名App-Instagram为例，Hook它的签名函数。"><a href="#关于某些请求携带sign参数的，后面的文章我会讲解到破解Sign函数（其实有时候不是直接的破解而是函数的Hook-有兴趣的可以提前了解下Android或者iOS的Hook，通过IDA找到sign函数-并使用cycript调用），之后的文章我会以国外的知名App-Instagram为例，Hook它的签名函数。" class="headerlink" title="关于某些请求携带sign参数的，后面的文章我会讲解到破解Sign函数（其实有时候不是直接的破解而是函数的Hook,有兴趣的可以提前了解下Android或者iOS的Hook，通过IDA找到sign函数,并使用cycript调用），之后的文章我会以国外的知名App Instagram为例，Hook它的签名函数。"></a>关于某些请求携带sign参数的，后面的文章我会讲解到破解Sign函数（其实有时候不是直接的破解而是函数的Hook,有兴趣的可以提前了解下Android或者iOS的Hook，通过IDA找到sign函数,并使用cycript调用），之后的文章我会以国外的知名App Instagram为例，Hook它的签名函数。</h5><p><img src="http://115.28.132.58:8080/docs/InsMeinv.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">来个美女提提神（图片来自Instagram的Https包数据），继续往下看</div></pre></td></tr></table></figure></p>
<h3 id="2-2、Https包"><a href="#2-2、Https包" class="headerlink" title="2.2、Https包"></a>2.2、Https包</h3><h4 id="2-2-1、Https简介"><a href="#2-2-1、Https简介" class="headerlink" title="2.2.1、Https简介"></a>2.2.1、Https简介</h4><h5 id="SSL相信大家都不陌生。其实Https就是在Http基础上通过SSL协议进行加密之后的网络传输。"><a href="#SSL相信大家都不陌生。其实Https就是在Http基础上通过SSL协议进行加密之后的网络传输。" class="headerlink" title="SSL相信大家都不陌生。其实Https就是在Http基础上通过SSL协议进行加密之后的网络传输。"></a>SSL相信大家都不陌生。其实Https就是在Http基础上通过SSL协议进行加密之后的网络传输。</h5><h5 id="并通过非对称和对称加密算法来对密码和数据进行加密。具体看下图："><a href="#并通过非对称和对称加密算法来对密码和数据进行加密。具体看下图：" class="headerlink" title="并通过非对称和对称加密算法来对密码和数据进行加密。具体看下图："></a>并通过非对称和对称加密算法来对密码和数据进行加密。具体看下图：</h5><p><img src="http://115.28.132.58:8080/docs/Https.png" alt=""></p>
<h5 id="1-Client明文将自己支持的一套加密规则、一个随机数-Random-C-发送给服务器"><a href="#1-Client明文将自己支持的一套加密规则、一个随机数-Random-C-发送给服务器" class="headerlink" title="1. Client明文将自己支持的一套加密规则、一个随机数(Random_C)发送给服务器."></a>1. Client明文将自己支持的一套加密规则、一个随机数(Random_C)发送给服务器.</h5><h5 id="2-Server返回自己选择的加密规则、CA证书（服务器地址、加密公钥、以及证书颁发机构）、外加一个通过加密规则和HASH算法生成的随机数-Random-S"><a href="#2-Server返回自己选择的加密规则、CA证书（服务器地址、加密公钥、以及证书颁发机构）、外加一个通过加密规则和HASH算法生成的随机数-Random-S" class="headerlink" title="2. Server返回自己选择的加密规则、CA证书（服务器地址、加密公钥、以及证书颁发机构）、外加一个通过加密规则和HASH算法生成的随机数(Random_S)"></a>2. Server返回自己选择的加密规则、CA证书（服务器地址、加密公钥、以及证书颁发机构）、外加一个通过加密规则和HASH算法生成的随机数(Random_S)</h5><h5 id="3-Client收到Server的消息之后会"><a href="#3-Client收到Server的消息之后会" class="headerlink" title="3. Client收到Server的消息之后会:"></a>3. Client收到Server的消息之后会:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a:验证证书（地址是否是正在访问的和机构是否合法）、</div><div class="line">b:自己生成一个随机的密码(Pre_master)并使用CA证书中的加密公钥进行加密(enc_pre_master)、</div><div class="line">c:计算出一个对称加密的enc_key,通过Random_C、Random_S、Pre_master、</div><div class="line">d:生成握手信息：使用约定好的Hash算法计算握手信息，并通过enc_key和约定好的加密算法对消息进行加密</div></pre></td></tr></table></figure>
<h5 id="4-Client将enc-pre-master、加密之后的握手消息发送给Server"><a href="#4-Client将enc-pre-master、加密之后的握手消息发送给Server" class="headerlink" title="4. Client将enc_pre_master、加密之后的握手消息发送给Server"></a>4. Client将enc_pre_master、加密之后的握手消息发送给Server</h5><h5 id="5-Server收到消息之后"><a href="#5-Server收到消息之后" class="headerlink" title="5. Server收到消息之后"></a>5. Server收到消息之后</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a: 收到enc_pre_master之后，会通过私钥进行解密（非对称加密算法）得到pre_master</div><div class="line">b: 通过pre_masrer、Random_C、Random_S计算得到协商密码 enc_key</div><div class="line">c: 通过enc_key解密握手信息，验证HASH是否和客户端发来的一致</div><div class="line">d: 生成握手信息同样适用enc_key和约定好的加密算法</div></pre></td></tr></table></figure>
<h5 id="6-Server发送握手信息给Client-也就是说Server验证通过了Client-并再次发送消息给Client让其验证自己"><a href="#6-Server发送握手信息给Client-也就是说Server验证通过了Client-并再次发送消息给Client让其验证自己" class="headerlink" title="6. Server发送握手信息给Client,也就是说Server验证通过了Client,并再次发送消息给Client让其验证自己"></a>6. Server发送握手信息给Client,也就是说Server验证通过了Client,并再次发送消息给Client让其验证自己</h5><h5 id="7-客户端拿到握手信息解密，握手结束。客户端解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束。"><a href="#7-客户端拿到握手信息解密，握手结束。客户端解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束。" class="headerlink" title="7. 客户端拿到握手信息解密，握手结束。客户端解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束。"></a>7. 客户端拿到握手信息解密，握手结束。客户端解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束。</h5><h5 id="8-正常加密通信，握手成功之后，所有的通信数据将由之前协商密钥enc-key及约定好的算法进行加密解密。"><a href="#8-正常加密通信，握手成功之后，所有的通信数据将由之前协商密钥enc-key及约定好的算法进行加密解密。" class="headerlink" title="8. 正常加密通信，握手成功之后，所有的通信数据将由之前协商密钥enc_key及约定好的算法进行加密解密。"></a>8. 正常加密通信，握手成功之后，所有的通信数据将由之前协商密钥enc_key及约定好的算法进行加密解密。</h5><h4 id="其中Https使用到的加密算法如下："><a href="#其中Https使用到的加密算法如下：" class="headerlink" title="其中Https使用到的加密算法如下："></a>其中Https使用到的加密算法如下：</h4><ul>
<li>非对称加密算法：RSA，DSA/DSS</li>
<li>对称加密算法：AES，RC4，3DES</li>
<li>HASH算法：MD5，SHA1，SHA256</li>
</ul>
<h3 id="2-2-2、-Charles抓取Https原理"><a href="#2-2-2、-Charles抓取Https原理" class="headerlink" title="2.2.2、 Charles抓取Https原理"></a>2.2.2、 Charles抓取Https原理</h3><h5 id="Charles本身就是一个协议代理工具，在上篇的Https原理上，客户端和服务器的所有通信都被Charles捕获到。"><a href="#Charles本身就是一个协议代理工具，在上篇的Https原理上，客户端和服务器的所有通信都被Charles捕获到。" class="headerlink" title="Charles本身就是一个协议代理工具，在上篇的Https原理上，客户端和服务器的所有通信都被Charles捕获到。"></a>Charles本身就是一个协议代理工具，在上篇的Https原理上，客户端和服务器的所有通信都被Charles捕获到。</h5><h5 id="如下图："><a href="#如下图：" class="headerlink" title="如下图："></a>如下图：</h5><p><img src="http://115.28.132.58:8080/docs/HttpsCharles.png" alt=""></p>
<p>主要步骤如下：</p>
<h5 id="1-Charles捕获Client发送给Server请求，并伪装成客户端向服务器发起握手请求"><a href="#1-Charles捕获Client发送给Server请求，并伪装成客户端向服务器发起握手请求" class="headerlink" title="1. Charles捕获Client发送给Server请求，并伪装成客户端向服务器发起握手请求"></a>1. Charles捕获Client发送给Server请求，并伪装成客户端向服务器发起握手请求</h5><h5 id="2-服务器响应，Charles获取到服务器的CA证书，并用根证书公钥进行解密，获取到服务器的CA证书公钥。然后Charles伪造自己的CA证书，伪装为服务器的CA证书发送给客户端"><a href="#2-服务器响应，Charles获取到服务器的CA证书，并用根证书公钥进行解密，获取到服务器的CA证书公钥。然后Charles伪造自己的CA证书，伪装为服务器的CA证书发送给客户端" class="headerlink" title="2. 服务器响应，Charles获取到服务器的CA证书，并用根证书公钥进行解密，获取到服务器的CA证书公钥。然后Charles伪造自己的CA证书，伪装为服务器的CA证书发送给客户端"></a>2. 服务器响应，Charles获取到服务器的CA证书，并用根证书公钥进行解密，获取到服务器的CA证书公钥。然后Charles伪造自己的CA证书，伪装为服务器的CA证书发送给客户端</h5><h5 id="3-客户端收到返回之后，和上面讲到的过程一样，证书校验、生成密码、并使用Charles伪装的证书公钥进行加密，并生成-Https通信的协商密码enc-key"><a href="#3-客户端收到返回之后，和上面讲到的过程一样，证书校验、生成密码、并使用Charles伪装的证书公钥进行加密，并生成-Https通信的协商密码enc-key" class="headerlink" title="3. 客户端收到返回之后，和上面讲到的过程一样，证书校验、生成密码、并使用Charles伪装的证书公钥进行加密，并生成 Https通信的协商密码enc_key"></a>3. 客户端收到返回之后，和上面讲到的过程一样，证书校验、生成密码、并使用Charles伪装的证书公钥进行加密，并生成 Https通信的协商密码enc_key</h5><h5 id="4-Charles捕获到Client发来的重要信息，并使用自己伪造的证书私钥将密文解密，获取到enc-key-然后Charles使用服务器之前返回的证书公钥对明文进行加密并发送给服务器"><a href="#4-Charles捕获到Client发来的重要信息，并使用自己伪造的证书私钥将密文解密，获取到enc-key-然后Charles使用服务器之前返回的证书公钥对明文进行加密并发送给服务器" class="headerlink" title="4. Charles捕获到Client发来的重要信息，并使用自己伪造的证书私钥将密文解密，获取到enc_key.然后Charles使用服务器之前返回的证书公钥对明文进行加密并发送给服务器"></a>4. Charles捕获到Client发来的重要信息，并使用自己伪造的证书私钥将密文解密，获取到enc_key.然后Charles使用服务器之前返回的证书公钥对明文进行加密并发送给服务器</h5><h5 id="5-去之前一样，服务器收到消息之后，用私钥解开并建立信任，然后发送加密的握手信息。"><a href="#5-去之前一样，服务器收到消息之后，用私钥解开并建立信任，然后发送加密的握手信息。" class="headerlink" title="5. 去之前一样，服务器收到消息之后，用私钥解开并建立信任，然后发送加密的握手信息。"></a>5. 去之前一样，服务器收到消息之后，用私钥解开并建立信任，然后发送加密的握手信息。</h5><h5 id="6-Charles截获服务器发来的握手密文，并用对称密钥解开，再用自己伪造证书的私钥加密传给客户端"><a href="#6-Charles截获服务器发来的握手密文，并用对称密钥解开，再用自己伪造证书的私钥加密传给客户端" class="headerlink" title="6. Charles截获服务器发来的握手密文，并用对称密钥解开，再用自己伪造证书的私钥加密传给客户端"></a>6. Charles截获服务器发来的握手密文，并用对称密钥解开，再用自己伪造证书的私钥加密传给客户端</h5><h5 id="7-客户端拿到加密信息后，用公钥解开，验证HASH。握手过程正式完成，客户端与服务器端就这样建立了”信任“。"><a href="#7-客户端拿到加密信息后，用公钥解开，验证HASH。握手过程正式完成，客户端与服务器端就这样建立了”信任“。" class="headerlink" title="7. 客户端拿到加密信息后，用公钥解开，验证HASH。握手过程正式完成，客户端与服务器端就这样建立了”信任“。"></a>7. 客户端拿到加密信息后，用公钥解开，验证HASH。握手过程正式完成，客户端与服务器端就这样建立了”信任“。</h5><ul>
<li>其实在整个过程中，最重要的就是enc_key,由于Charles从一开始伪造并获取了enc_key，所以在整个通信过程中Charles充当第三者，所有信息对其来讲都是透明的。</li>
<li>其次就是根证书，这是https一个信任链的开始。这也是Charles伪造的CA证书能获得双方信任的关键。</li>
</ul>
<h3 id="2-2-3、演示Charles抓取Https"><a href="#2-2-3、演示Charles抓取Https" class="headerlink" title="2.2.3、演示Charles抓取Https"></a>2.2.3、演示Charles抓取Https</h3><blockquote>
<p>原理清楚之后，其实操作就很简单了，操作的核心点就是根证书。</p>
</blockquote>
<ul>
<li>安装根证书（Charles Root Certificate）<br><img src="http://115.28.132.58:8080/docs/CharlesRootCA.png" alt=""></li>
<li>让系统信任该证书<br><img src="http://115.28.132.58:8080/docs/TrustCharlesRootCa.png" alt=""></li>
<li>接下来将需要抓的Https链接加入到CharlesSSL代理规则中，443是Https的默认端口<br><img src="http://115.28.132.58:8080/docs/SSLProxy.png" alt=""><br>当然你也可以像我最后一条一样，使用 *:443 来抓取所有https的包。</li>
<li>通过浏览器访问自己要抓的链接，这样所有的Https都可以像Http一样明文展示都我们面前。<br><img src="http://115.28.132.58:8080/docs/HttpsGoogle.png" alt=""></li>
</ul>
<h2 id="第三、手机抓包"><a href="#第三、手机抓包" class="headerlink" title="第三、手机抓包"></a>第三、手机抓包</h2><blockquote>
<p>手机抓包的原理其实也很简单，让手机和抓包工具处于同一局域网，并将手机的WifiProxy手动代理到电脑的Ip和Charles设置的抓包端口上，具体操作可在网上找到,具体见<a href="http://blog.csdn.net/richer1997/article/details/52198024" target="_blank" rel="external">http://blog.csdn.net/richer1997/article/details/52198024</a></p>
</blockquote>
<h5 id="我这边主要讲一下手机端Https包的抓取，其实和浏览器的抓取一样："><a href="#我这边主要讲一下手机端Https包的抓取，其实和浏览器的抓取一样：" class="headerlink" title="我这边主要讲一下手机端Https包的抓取，其实和浏览器的抓取一样："></a>我这边主要讲一下手机端Https包的抓取，其实和浏览器的抓取一样：</h5><ul>
<li>首先需要安装Charles的根证书到手机上。<br><img src="http://115.28.132.58:8080/docs/InstallRoomIOS.png" alt=""></li>
<li>点击之后，会弹出让你在手机上配置代理到对应Ip和端口，之后通过手机浏览器打开chls.pro/ssl<br><img src="http://115.28.132.58:8080/docs/DownloadCA.png" alt=""><h5 id="使用手机访问该链接之后，会自动被识别为证书，并跳转到：-当然我这里已经是安装过的，未安装的点击右上角安装即可"><a href="#使用手机访问该链接之后，会自动被识别为证书，并跳转到：-当然我这里已经是安装过的，未安装的点击右上角安装即可" class="headerlink" title="使用手机访问该链接之后，会自动被识别为证书，并跳转到：(当然我这里已经是安装过的，未安装的点击右上角安装即可)"></a>使用手机访问该链接之后，会自动被识别为证书，并跳转到：(当然我这里已经是安装过的，未安装的点击右上角安装即可)</h5><img src="http://115.28.132.58:8080/docs/WechatIMG3.jpeg" alt=""></li>
<li>之后就类似与PC端抓Https包原理一样，手机端的证书被作为根证书使用，并通过Charles拿到enc_key.将所有通信过程透明化。</li>
</ul>
<h2 id="第四、Charles的附加功能"><a href="#第四、Charles的附加功能" class="headerlink" title="第四、Charles的附加功能"></a>第四、Charles的附加功能</h2><blockquote>
<p>在我刚开始使用Charles的时候，我只是用来简单的抓抓接口，直到我看到别人使用BurpSuite自定义请求数据并Repeat的时候，我在考虑Charles是否也有这种功能。当然不出我所料，Charles也是支持的。</p>
</blockquote>
<h5 id="在对应接口上点击右键，出现菜单，其中我经常使用到的就是Compose、Repeat和RepeatAdvanced"><a href="#在对应接口上点击右键，出现菜单，其中我经常使用到的就是Compose、Repeat和RepeatAdvanced" class="headerlink" title="在对应接口上点击右键，出现菜单，其中我经常使用到的就是Compose、Repeat和RepeatAdvanced"></a>在对应接口上点击右键，出现菜单，其中我经常使用到的就是Compose、Repeat和RepeatAdvanced</h5><p><img src="http://115.28.132.58:8080/docs/CharlesMenu.png" alt=""></p>
<h5 id="Compose-可直接自定义对应的请求，并执行该请求。这个对我们抓包用处很大。我们可以从中得到该接口的必填参数等等的。"><a href="#Compose-可直接自定义对应的请求，并执行该请求。这个对我们抓包用处很大。我们可以从中得到该接口的必填参数等等的。" class="headerlink" title="Compose:可直接自定义对应的请求，并执行该请求。这个对我们抓包用处很大。我们可以从中得到该接口的必填参数等等的。"></a>Compose:可直接自定义对应的请求，并执行该请求。这个对我们抓包用处很大。我们可以从中得到该接口的必填参数等等的。</h5><h5 id="Repeat：很简单就是执行一次重复请求操作"><a href="#Repeat：很简单就是执行一次重复请求操作" class="headerlink" title="Repeat：很简单就是执行一次重复请求操作"></a>Repeat：很简单就是执行一次重复请求操作</h5><h5 id="Repeat-Advanved：重复请求的高级操作，可自定义重复的次数、每隔多少秒执行。这个功能对于我们的接口的压测是很有用的。"><a href="#Repeat-Advanved：重复请求的高级操作，可自定义重复的次数、每隔多少秒执行。这个功能对于我们的接口的压测是很有用的。" class="headerlink" title="Repeat Advanved：重复请求的高级操作，可自定义重复的次数、每隔多少秒执行。这个功能对于我们的接口的压测是很有用的。"></a>Repeat Advanved：重复请求的高级操作，可自定义重复的次数、每隔多少秒执行。这个功能对于我们的接口的压测是很有用的。</h5><h5 id="除了这几个我常用的功能，当然Charles还有更多更加实用的功能，如过滤、排序等等。还需要大家去自行使用，发现更多更好、并适用于自己的功能。"><a href="#除了这几个我常用的功能，当然Charles还有更多更加实用的功能，如过滤、排序等等。还需要大家去自行使用，发现更多更好、并适用于自己的功能。" class="headerlink" title="除了这几个我常用的功能，当然Charles还有更多更加实用的功能，如过滤、排序等等。还需要大家去自行使用，发现更多更好、并适用于自己的功能。"></a>除了这几个我常用的功能，当然Charles还有更多更加实用的功能，如过滤、排序等等。还需要大家去自行使用，发现更多更好、并适用于自己的功能。</h5><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote>
<p>抓包的用处其实很大，有时候可以用来调试我们的接口、有时候也可以用来做一些对工作有益的事，当然并”不建议”用来攻击别人的网络。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python新手引导第二篇]]></title>
      <url>https://xiyoumc.github.com/2017/03/03/Python%E6%96%B0%E6%89%8B%E5%BC%95%E5%AF%BC%E7%AC%AC%E4%BA%8C%E7%AF%87/</url>
      <content type="html"><![CDATA[<h1 id="Python新手引导-第二篇-你不知道的Python"><a href="#Python新手引导-第二篇-你不知道的Python" class="headerlink" title="Python新手引导 第二篇 你不知道的Python"></a>Python新手引导 第二篇 你不知道的Python</h1><blockquote>
<p>###阅读本文需要4.66分钟</p>
</blockquote>
<a id="more"></a>
<p>上一篇进行了简单的Python讲解，包括历史、多版本共存和安装。若有不明白的同学，可尽情在公众号上给我发消息。保证”第一时间”回复.</p>
<ol>
<li>Python解释器</li>
<li>编写、运行第一个Python</li>
<li>atom-runner</li>
</ol>
<h2 id="一、Python解释器"><a href="#一、Python解释器" class="headerlink" title="一、Python解释器"></a>一、Python解释器</h2><blockquote>
<p>Python代码是以.py为扩展名的文本文件。要执行代码，就需要Python解释器去执行.py文件。</p>
</blockquote>
<p>以下将介绍多种Python解释器:</p>
<h3 id="A、-CPython"><a href="#A、-CPython" class="headerlink" title="A、 CPython"></a>A、 CPython</h3><p>Python官方的解释器是：CPython.这个解释器是用C语言开发的，因此叫CPython。在终端执行 python 启动的就是CPython解释器。<br><img src="http://115.28.132.58:8080/docs/CPython.png" alt=""></p>
<h3 id="B、-IPython"><a href="#B、-IPython" class="headerlink" title="B、 IPython"></a>B、 IPython</h3><p>Ipython是基于CPython的交互式解释器。执行 Python的能力和CPtython一样。<br>可以变量自动补全、自动缩进。与CPython不一样的是： CPython使用&gt;&gt;&gt;作为提示符，而IPython使用In[序号]:<br><img src="http://115.28.132.58:8080/docs/IPython.png" alt=""></p>
<h3 id="C、-Pypy"><a href="#C、-Pypy" class="headerlink" title="C、 Pypy"></a>C、 Pypy</h3><p>Pypy是Python开发者为了更好的Hack Python创建的项目。</p>
<p>用Python实现的Python</p>
<h3 id="D、-Jython"><a href="#D、-Jython" class="headerlink" title="D、 Jython"></a>D、 Jython</h3><p>Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。<br>这个也是我之前在写一个Java项目的时候用到的解释器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;!-- https://mvnrepository.com/artifact/jython/jython --&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;jython&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;jython&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;2.5.2&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>Java项目引入Jython之后，会将本机Python环境应用到本项目中。在Java和Python相互调用中起到了重要的作用。</p>
<h2 id="二、编写、运行第一个Python程序"><a href="#二、编写、运行第一个Python程序" class="headerlink" title="二、编写、运行第一个Python程序"></a>二、编写、运行第一个Python程序</h2><blockquote>
<p>当然在终端中，可以直接通过Python来启动CPython并进行编辑并运行，但这样的缺点就是没法保存，再次执行还必须得复制进行。所以在实际的应用场景中，我们使用文本编辑器来编写Python代码。</p>
</blockquote>
<p>以下推荐两款文本剪辑器：</p>
<ul>
<li>Atom，免费、可安装多种插件来更高效的编写代码。<br><img src="http://115.28.132.58:8080/docs/Atom_HelloWorld.png" alt=""></li>
<li>NodePad++,免费、在Window上很实用的文本编辑器<br><img src="http://115.28.132.58:8080/docs/nodepad.jpeg" alt=""></li>
</ul>
<h4 id="编写并运行第一个Python程序"><a href="#编写并运行第一个Python程序" class="headerlink" title="编写并运行第一个Python程序"></a>编写并运行第一个Python程序</h4><ol>
<li>安装好编辑器之后，打开编辑，新建文件，输入:<br><img src="http://115.28.132.58:8080/docs/PythonPrint.png" alt=""></li>
<li>编辑Python文件后，将其保存为Hello.py并放到自己的开发目录如 ~/Dev 或者 C:/dev 都可以 </li>
<li>通过cd 命令定位到文件的目录,并使用python命令来运行<br><img src="http://115.28.132.58:8080/docs/RunPython.png" alt=""></li>
<li>如果当前文件夹没有Hello.py，会报错如下：<br><img src="http://115.28.132.58:8080/docs/RunPythonError.png" alt=""> </li>
</ol>
<h2 id="三、atom-runner插件"><a href="#三、atom-runner插件" class="headerlink" title="三、atom-runner插件"></a>三、atom-runner插件</h2><blockquote>
<p>每一门语言的开始，相信大家都会去找到一个适合自己的编辑器，类似SublineText等等的。当然SublineText也可以运行Python，但是我个人比较推荐Atom。</p>
</blockquote>
<p><a href="https://github.com/lsegal/atom-runner" target="_blank" rel="external">atom-runner</a>Atom中的开源插件，可用来执行Python脚本。<br>直接在Atom settings-&gt;install 中搜索atom-runner,安装即可</p>
<p><img src="http://115.28.132.58:8080/docs/atom-runner.png" alt=""></p>
<blockquote>
<p>该插件官方文档指明，可支持JavaScript、CoffeeScript、Ruby、Python、Go、Bash 和 PowerShell scripts.</p>
<h4 id="可执行命令"><a href="#可执行命令" class="headerlink" title="可执行命令"></a>可执行命令</h4><ul>
<li>Ctrl+R (Alt+R on Win/Linux)运行当前活动窗口</li>
<li>Ctrl+Shift + R (Alt+Shif+R on Win/Linux)运行在活动窗口的选择文本</li>
<li>Ctrul+Shift+C 杀掉当前正在运行的进程</li>
<li>Escap 关闭正在运行的窗口</li>
</ul>
</blockquote>
<p>运行结果如下<br><img src="http://115.28.132.58:8080/docs/HelloWorld.png" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇阅读完成之后，花上几分钟时间自行编写并运行下Python，熟悉下Python的环境。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python新手引导第一篇]]></title>
      <url>https://xiyoumc.github.com/2017/03/03/Python%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</url>
      <content type="html"><![CDATA[<h1 id="Python新手引导-第一篇"><a href="#Python新手引导-第一篇" class="headerlink" title="Python新手引导 第一篇"></a>Python新手引导 第一篇</h1><blockquote>
<p>阅读本文需要3.66分钟</p>
</blockquote>
<a id="more"></a>
<p>目前比较流行的Python版本有2.x 和3.x,不过本人将介绍兼容所有版本的神器</p>
<ol>
<li>Python简介</li>
<li>pyenv</li>
<li>mac、Linux、Windows下安装Python</li>
</ol>
<h2 id="一、Python简介"><a href="#一、Python简介" class="headerlink" title="一、Python简介"></a>一、Python简介</h2><blockquote>
<p>Python是由著名的“龟叔”Guido van Rossum在1989年，为了打发无聊的圣诞节而编写的一个编程语言</p>
</blockquote>
<p>以下数据是通过 TIOBE获取到的一组编程语言排行榜：<br> <img src="http://115.28.132.58:8080/docs/20160118203112196" alt=""></p>
<p> 总的来说，这几种Top编程语言各有千秋。C是可以用来编写操作系统、最贴近硬件的语言。而Python是用来编写应用程序的高级编程语言。</p>
<p> 然而Python最大的好处就是有很多现成的组件让你来用，就类似让你去搭建发送邮件的自动化工具，如果从底层发送邮件开始，那么我觉得你可能需要一年半载来完成这个工作。那么这时候就体现出来Python的重要性，只需要十行左右的代码你就可以轻松的发送邮件。</p>
<p> Python为我们提供了大量的基础代码库，覆盖了网络、文件、GUI、数据库、文件等等大量的内容。<br> 在<a href="https://pypi.python.org/pypi" target="_blank" rel="external">Pypi</a>你可以搜索到任何你想用到的库。</p>
<p> 当然Python也是有缺点的，如运行速度慢、代码不能加密等等的。其实总而言之这些都可以忽略，因为上层的编译语言永远都快不过C语言。</p>
<h2 id="二、Pyenv"><a href="#二、Pyenv" class="headerlink" title="二、Pyenv"></a>二、Pyenv</h2><blockquote>
<p>当前比较流行的Python版本包括了2.x 和3.x，但是有些代码需要在2.x也有一部分是在3.x因此Python环境的管理是必须要有的。</p>
<p>Pyenv是一个Python版本管理器</p>
</blockquote>
<h4 id="A-安装Pyenv"><a href="#A-安装Pyenv" class="headerlink" title="A)安装Pyenv"></a>A)安装Pyenv</h4><p>在终端执行如下命令以安装 pyenv 及其插件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash</div></pre></td></tr></table></figure></p>
<p>安装完成后，根据提示将如下语句加入到~/.bashrc中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">export PYENV_ROOT=&quot;$HOME/.pyenv&quot;</div><div class="line">export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;</div><div class="line">eval &quot;$(pyenv init -)&quot;</div><div class="line">eval &quot;$(pyenv virtualenv-init -)&quot;   # 这句可以不加</div></pre></td></tr></table></figure></p>
<h4 id="B-使用"><a href="#B-使用" class="headerlink" title="B)使用"></a>B)使用</h4><p>pyenv 总共有11条不同的命令，具体可见：<a href="https://github.com/yyuu/pyenv/blob/master/COMMANDS.md#command-reference" target="_blank" rel="external">Comment Reference</a>.下面就最重要的几条进行说明：</p>
<h2 id="1-pyenv-versions"><a href="#1-pyenv-versions" class="headerlink" title="1. pyenv versions"></a>1. pyenv versions</h2><p>查看当前pyenv可检测到的所有版本，处于激活状态的版本前以 * 标注.<br><img src="http://115.28.132.58:8080/docs/WX20170303-190604.png" alt=""></p>
<h2 id="2-pyenv-version"><a href="#2-pyenv-version" class="headerlink" title="2. pyenv version"></a>2. pyenv version</h2><p>查看当前处于激活状态的版本，括号中内容表示这个版本是由哪条路径激活的<br><img src="http://115.28.132.58:8080/docs/WX20170303-190922.png" alt=""></p>
<h2 id="3-pyenv-install"><a href="#3-pyenv-install" class="headerlink" title="3. pyenv install"></a>3. pyenv install</h2><p>使用python-build(插件)安装一个Python版本，到$PYENV_ROOT/versions路径下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pyenv install -v <span class="number">3.4</span><span class="number">.7</span></div></pre></td></tr></table></figure></p>
<h2 id="4-pyenv-uninstall"><a href="#4-pyenv-uninstall" class="headerlink" title="4. pyenv uninstall"></a>4. pyenv uninstall</h2><p>卸载一个版本</p>
<h2 id="5-pyenv-rehash"><a href="#5-pyenv-rehash" class="headerlink" title="5. pyenv rehash"></a>5. pyenv rehash</h2><p>为所有已安装的可执行文件创建shims,因此，每当你增删了Python版本或者带有可执行文件的包(如pip)以后，都必须执行一次该命令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">python install -v <span class="number">3.4</span><span class="number">.7</span></div><div class="line">python rehash</div></pre></td></tr></table></figure>
<h2 id="6-pyenv-global"><a href="#6-pyenv-global" class="headerlink" title="6. pyenv global"></a>6. pyenv global</h2><p>设置全局的Python版本，通过将版本写入~/.pyenv/version文件的方式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pyenv <span class="keyword">global</span> <span class="number">3.4</span><span class="number">.0</span></div></pre></td></tr></table></figure></p>
<h2 id="7-pyenv-local"><a href="#7-pyenv-local" class="headerlink" title="7. pyenv local"></a>7. pyenv local</h2><p>设置面向程序的本地版本。该方式优先级高于global。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pyenv local <span class="number">3.4</span><span class="number">.7</span></div></pre></td></tr></table></figure></p>
<h2 id="8-pyenv-shell"><a href="#8-pyenv-shell" class="headerlink" title="8. pyenv shell"></a>8. pyenv shell</h2><p>设置面向shell的Python版本，通过设置当前 shell的PYENV_VERSION环境变量的方式。这个方式的优先级比local、global都高。 –unset可以取消当前shell设置的版本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pyenv shell pypy<span class="number">-2.2</span><span class="number">.1</span></div><div class="line">pyenv shell --unset</div></pre></td></tr></table></figure></p>
<h2 id="三、安装Python环境"><a href="#三、安装Python环境" class="headerlink" title="三、安装Python环境"></a>三、安装Python环境</h2><p>因为Python是跨平台，因此它可以运行在Windows、mac和各种Linux/Unix系统上。不过个人建议使用Mac，若因为穷，那么可以选择Linux/Unix。因为Windows的终端用到你吐，虽然可以在Windows上安装其他的终端程序，但是还是解决不了体验。</p>
<h4 id="A-在Mac上安装Python"><a href="#A-在Mac上安装Python" class="headerlink" title="A) 在Mac上安装Python"></a>A) 在Mac上安装Python</h4><p>OSX 10.8+都自带了2.7版本的Python.要安装最新的Python可使用brew install python3来搞定</p>
<h4 id="B-在Linux上安装Python"><a href="#B-在Linux上安装Python" class="headerlink" title="B) 在Linux上安装Python"></a>B) 在Linux上安装Python</h4><p>当前熟悉Linux的自行安装Python就可以了。否则，还是换到Windows上。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>安装成功之后，打开终端，输入python就可以了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Github系列教程二 「平台介绍」]]></title>
      <url>https://xiyoumc.github.com/2017/03/03/Github%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%8C%20%E5%B9%B3%E5%8F%B0%E8%BE%83%E5%B0%91/</url>
      <content type="html"><![CDATA[<h3 id="本文同步在我的公众号-DeveloperPython"><a href="#本文同步在我的公众号-DeveloperPython" class="headerlink" title="本文同步在我的公众号: DeveloperPython"></a>本文同步在我的公众号: DeveloperPython</h3><p><img src="http://upload-images.jianshu.io/upload_images/4653472-1ff8d4743422cfaf?imageMogr2/auto-orient/strip" alt=""><br>相信昨天大家看过 <a href="http://mp.weixin.qq.com/s?__biz=MzU3ODAxNDcwNQ==&amp;mid=2247483866&amp;idx=1&amp;sn=9692ca0d4a25ee4675d073e9643b7e30&amp;chksm=fd7a9d44ca0d1452f0e7d55d412e5469a3d82fbb00153e7d9b99a33e0424d6eb47b54903b5ad&amp;scene=21#wechat_redirect" target="_blank" rel="external">Github系列教程一 「开门」</a>之后，已经对Github的简介和发展史有了一个详细的了解。</p>
<p>那么多的不说，我继续更新。</p>
<p>为了更好的使用Github，第一步去了解这个平台是重要的。</p>
<p>因此这篇我将针对Github平台进行一个全面的讲解。</p>
<h2 id="1、注册Github账号"><a href="#1、注册Github账号" class="headerlink" title="1、注册Github账号"></a>1、注册Github账号</h2><p>访问 <a href="https://github.com/官网。" target="_blank" rel="external">https://github.com/官网。</a></p>
<p>首页就是一个注册Github的入口。<br><img src="http://upload-images.jianshu.io/upload_images/4653472-5d3b14792b78caf5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这里就很简单了，填写你的用户名、邮箱和密码。</p>
<p>不过提醒下，这个用户名比较重要，这相当于是你在Github的ID。</p>
<p>上一篇文章讲过Github可以搭建个人博客username.github.io。那么这个用户名就会在这里用到。</p>
<p>所以建议填写一个代表自己的ID。</p>
<p>比如我的xiyouMc，博客就是xiyouMc.github.io。</p>
<h2 id="2、Github主面板"><a href="#2、Github主面板" class="headerlink" title="2、Github主面板"></a>2、Github主面板</h2><p>注册完成之后，就来到了Github的主面板。</p>
<p>如果你是新注册的，那么不会像我这么丰富，不过玩上一段时间也就差不多类似了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4653472-f9ed3b8bfceb47f1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>以下，我针对主要的两点进行讲解：</p>
<p><strong>Github的工具栏</strong></p>
<p>1、Logo<br>左上角这个Logo在Github每个页面都有，同时也是可以点击的。</p>
<p>当你在Github里面打开了很多页面，然后想快速回到这个面板。直接点击左上角的Logo即可。</p>
<p>2、搜索项目的入口<br>这里可以输入关键字，去搜索自己想要的项目。</p>
<p>3、Pull requests(PR)<br>一个可查看自己贡献代码给其他人项目的面板。</p>
<p>关于pr的含义，就是当自己针对别人的开源项目做了改动之后，就可以将这些改动pull requests 到对应开源者的项目中。</p>
<p>4、Issues<br>这个你可以理解为Github上的聊天功能。</p>
<p>用这个功能你可以很方便的给别人的项目提建议或者提Bug。同时你们也可以在里面进行沟通。</p>
<p>5、Gist<br>如果你没有自己的开源项目，但是你有很不错的代码片段。就可以在Gist里面将自己优秀的代码片段进行提交。</p>
<p>当然，你可以在Gist里面学习别人优秀的代码片段.<br><img src="http://upload-images.jianshu.io/upload_images/4653472-edf4803b2fbf547a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>动态栏</strong></p>
<p>这里是你关注人的动态列表和你自己项目的状态记录。<br>所以在Github上多关注一些大牛，你会看到他们的动态，包括他们点赞的项目和创建的项目。这些项目也绝对是有水平的。</p>
<h2 id="3、Github个人主页"><a href="#3、Github个人主页" class="headerlink" title="3、Github个人主页"></a>3、Github个人主页</h2><p>点击右上角的头像，会弹出下拉列表，在里面点击 Your profile。<br><img src="http://upload-images.jianshu.io/upload_images/4653472-fd77f7f2c44fefef?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>进来之后，就进入了个人的主页。<br><img src="http://upload-images.jianshu.io/upload_images/4653472-63d6baee40eaa391?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>你会看到我的简介里面养了条狗。<br>其中，几个重要的功能，我也都在上面标注出来了。</p>
<h2 id="4、修改个人标签"><a href="#4、修改个人标签" class="headerlink" title="4、修改个人标签"></a>4、修改个人标签</h2><p>同样的，参考上面 Your profile。在那个下拉列表中，会有一个Settings，点击之后就会来到个人设置页面。<br><img src="http://upload-images.jianshu.io/upload_images/4653472-c322da7781011eb4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这里面的内容，也都很清楚了。比如修改头像、修改用户名、简介等等的。</p>
<p>不过到这里，我就讲个课外话。</p>
<p>很多人都说Github是免费的，那他们怎么赢利的呢?</p>
<p>我可以很明确的告诉你，Github有付费功能，而且有点贵。</p>
<p>它的付费功能其实也很简单，就是一个创建私有仓库的权限。如果你买了的话，就可以创建私有的项目，当然私有的意思就是别人无法看到你的代码。</p>
<p>具体价格，每个月大概7刀，折合人民币就是42块钱左右。所以如果不是非必须使用私有，还是建议别买这个。</p>
<h2 id="5、创建项目"><a href="#5、创建项目" class="headerlink" title="5、创建项目"></a>5、创建项目</h2><p>点击 New repository，就进入了创建项目的页面。<br><img src="http://upload-images.jianshu.io/upload_images/4653472-e6ecdc3e4b4c112d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>填写你的项目名字、加上一句高大上的简介，选择Public，然后点击Create repository。就走出了开源的第一步。</p>
<p>创建之后的项目面板大概是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/4653472-38b3d9f4e6a939fc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>因为这是一个已经成型的项目，所以说，如果你们是刚创建的一个项目，那么不会有这么丰富的内容。最多里面也就一个项目的说明文档Readme.md。当然这是需要使用 Markdown语法的，简称md,也同样是程序员必备的技能。</p>
<h2 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h2><p>其实这篇文章写得相对简单点，如果你是一个已经使用Github一段时间的可能帮助不大。但是如果你刚接触或者没接触过Github，我相信这些基础知识对于你来讲还是有很大意义的。</p>
<p>所以走出你的开源第一步，勇敢的将自己的项目提交到Github吧。</p>
<hr>
<p>扫描二维码，关注公众号</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4653472-b61ffc02ee6e4db5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>生活不止眼前的苟且，还有手下的代码、<br>和嘴上的扯淡<br>——</p>
<p>个人博客: <a href="http://xiyoumc.0x2048.com/" target="_blank" rel="external">http://xiyoumc.0x2048.com/</a></p>
<p>Github:<a href="https://www.github.com/xiyouMc" target="_blank" rel="external">https://www.github.com/xiyouMc</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Charles破解教程，适用于所有版本]]></title>
      <url>https://xiyoumc.github.com/2017/02/08/charles_break/</url>
      <content type="html"><![CDATA[<h1 id="Charles-注册码"><a href="#Charles-注册码" class="headerlink" title="Charles 注册码"></a>Charles 注册码</h1><h3 id="1-Windows-用户"><a href="#1-Windows-用户" class="headerlink" title="1. Windows 用户"></a>1. Windows 用户</h3><p>RegName: ANONYMOUS@chinapyg.com<br>Reg_Key: 5fae99ec65736945ba<br>官方下载后可直接激活。神key.</p>
<h3 id="2-Mac-用户"><a href="#2-Mac-用户" class="headerlink" title="2. Mac 用户"></a>2. Mac 用户</h3><p>方式一如果不行，方式二绝对可以。</p>
<h4 id="1-方式一"><a href="#1-方式一" class="headerlink" title="1. 方式一"></a>1. 方式一</h4><p>账号：WaitsUn.com<br>密码：vapg-fold-dreg-inky</p>
<h4 id="2-方式二"><a href="#2-方式二" class="headerlink" title="2. 方式二"></a>2. 方式二</h4><p>先安装Charles，然后在终端中执行下面的命令即可实现破解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">charles=/Applications/Charles.app/Contents/Java/charles.jar</div><div class="line">dir=charleshack</div><div class="line">mkdir $dir</div><div class="line">cd $dir</div><div class="line">cat &gt;&gt; License.java &lt;&lt;EOF</div><div class="line">package com.xk72.charles;</div><div class="line">public final class License &#123;</div><div class="line">    public static boolean a() &#123; return true; &#125;</div><div class="line">    public static String b() &#123; return &quot;http://www.gfzj.us&quot;; &#125;</div><div class="line">    public static String a(String name, String key) &#123; return null; &#125;</div><div class="line">&#125;</div><div class="line">EOF</div><div class="line">javac -encoding UTF-8 License.java -d .&amp;&amp; jar -uvf $charles com/xk72/charles/License.class</div><div class="line">cd .. &amp;&amp; rm -rf $dir</div></pre></td></tr></table></figure>
<a id="more"></a>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Shell语言基本教程]]></title>
      <url>https://xiyoumc.github.com/2017/02/07/linux_shell/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac、Linux安装libimobiledevice]]></title>
      <url>https://xiyoumc.github.com/2017/02/06/libimobiledevice/</url>
      <content type="html"><![CDATA[<h3 id="linux连接iOS设备并且安装ipa应用"><a href="#linux连接iOS设备并且安装ipa应用" class="headerlink" title="linux连接iOS设备并且安装ipa应用"></a>linux连接iOS设备并且安装ipa应用</h3><p>Android有个adb命令，可以很方便的做一些事情，比如直接安装应用。但是因为苹果比较封闭，没有直接的命令可以使用。但是有大牛做出了这样的东西–libimobiledevice<br><img src="https://github.com/xiyouMc/xiyoumc.github.io/blob/master/images/idevice.png?raw=true" alt="zls"><br><a id="more"></a></p>
<h3 id="关于libimobiledevice的描述"><a href="#关于libimobiledevice的描述" class="headerlink" title="关于libimobiledevice的描述"></a>关于libimobiledevice的描述</h3><p>A library to communicate with services of Apple iOS devices using native protocols.</p>
<p>ibimobiledevice又称libiphone，是一个开源包，可以让Linux支持连接iPhone/iPod Touch等iOS设备。由于苹果官方并不支持Linux系统，但是Linux上的高手绝对不能忍受因为要连接iOS设备就换用操作系统这个事儿。因此就有人逆向出iOS设备与Windows/Mac Host接口的通讯协议，最终成就了横跨三大桌面平台的非官方版本USB接口library。经常用Linux系统的人一定对libimobiledevice不陌生，但是许多Windows和Mac用户也许就不知道了。事实上，它同iTools一样，都是可以替代iTunes，进行iOS设备管理的工具。因为源码是开放的，可以自行编译，所以对很多开发者而言可以说更为实用。</p>
<p>可以自行到GitHub上下载编译<a href="https://github.com/libimobiledevice/libimobiledevice" target="_blank" rel="external">https://github.com/libimobiledevice/libimobiledevice</a></p>
<p>不过这里用简单的方式分别在mac已经ubuntu上进行安装</p>
<h4 id="在mac下安装可以使用brew，brew安装方法可以自行百度"><a href="#在mac下安装可以使用brew，brew安装方法可以自行百度" class="headerlink" title="在mac下安装可以使用brew，brew安装方法可以自行百度"></a>在mac下安装可以使用brew，brew安装方法可以自行百度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> sudo brew update</div><div class="line"> sudo brew install libimobiledevice</div><div class="line">#libimobiledevice中并不包含ipa的安装命令，所以还需要安装</div><div class="line"> sudo brew install ideviceinstaller</div></pre></td></tr></table></figure>
<h4 id="ubuntu下安装需要添加一个新的软件库，里面包含了libimobiledevice"><a href="#ubuntu下安装需要添加一个新的软件库，里面包含了libimobiledevice" class="headerlink" title="ubuntu下安装需要添加一个新的软件库，里面包含了libimobiledevice"></a>ubuntu下安装需要添加一个新的软件库，里面包含了libimobiledevice</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:pmcenery/ppa</div><div class="line">sudo apt-get update</div><div class="line">apt-get install libimobiledevice-utils</div><div class="line">sudo apt-get install ideviceinstaller</div></pre></td></tr></table></figure>
<p>这里面包含了很多命令，如下<br><img src="https://github.com/xiyouMc/xiyoumc.github.io/blob/master/images/idevice.png?raw=true" alt="zls"></p>
<h3 id="如要安装一个ipa文件到手机上可以使用"><a href="#如要安装一个ipa文件到手机上可以使用" class="headerlink" title="如要安装一个ipa文件到手机上可以使用"></a>如要安装一个ipa文件到手机上可以使用</h3><p>ideviceinstaller -i 命令安装一个ipa文件到手机上，如果是企业签名的，非越狱机器也可以直接安装了</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2016年度总结]]></title>
      <url>https://xiyoumc.github.com/2017/01/24/2016%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="2016年度总结"><a href="#2016年度总结" class="headerlink" title="2016年度总结"></a>2016年度总结</h1><blockquote>
<p>2016年很快，离上次写总结已经一年了。平时文档倒是写的不少，但是真正要总结起来自己，确实有点说不出口，那么就简单的总结下。从事业、生活等。</p>
</blockquote>
<a id="more"></a>
<ul>
<li><p>事业</p>
<blockquote>
<p>事业即我的技术，从刚进入职场，就开始做框架上的东西，现在想来这也是一个很不错的开始。因为少了业务的繁杂，多了技术的沉淀和技术的优化—Hybrid。<br>Hybrid是一个混合式开发的技术，通过JSBridge来桥接H5和Native。这个框架着实是影响到了我之后的发展规划。在开发这个系统的过程中，学习到了很多：</p>
</blockquote>
<ol>
<li>JS和H5当然是第一个学习到的东西，这两个技术一直是我在学生时期想要学习的但是一直没有沉下心来学习。</li>
<li>Module间的依赖关系，一年半左右的Hybrid开发，也确实是让我积累了很多关于模块依赖、接口开发等等的技术，并一步步提升自己的开发效率。</li>
<li>整个App的插件化开发，在开发Hybrid的同时我经常会去问框架同学问题，问他们关于App插件化、动态注入、懒加载等等的技术，这也是为自己后面开发插件化框架打下了基础。</li>
<li>插件化框架，去年中旬花了一段时间去研究ClassLoader，遇到了很多坑，也一一进行了填补,虽然不是一个多么牛逼的框架，但是确实是让我学习到了很多。当然现在也是开源在我的Github，<a href="https://github.com/xiyouMc/AppDynamicFramework" target="_blank" rel="external">Apk插件化开发</a></li>
<li>接触业务，去年下半年一直在开发业务中，一个从零开始的业务，这也算是将自己沉淀的技术进行一次应用的过程，业务有时候根本不是取决于你的技术，而是取决于各种因素，如果你是程序员你会懂得。</li>
<li>16年我也花了很多时间在Github上，每天必看Trending. Java、JS、Html等等的技术。16年也认识了很多业内的大神。</li>
<li>2017年将转型Growth Hacker，致力于公司的数据增长，将会放下Android的重心，当然Android还依然是我的一个长处。</li>
</ol>
</li>
</ul>
<ul>
<li><p>生活</p>
<blockquote>
<p>对我而言，技术的产出永远都是生活质量的提升。有时候我在想:”如果能让我开心、很爽的开发自己喜欢的技术，那么金钱对我来说都是多余的”<br>这个想法是多么幼稚.下半年一直在考虑房子的问题，看了周围一大圈，发现全都是16年9 10月份上涨之后的情况，当然貌似也是G20导致的。<br>据周围人的看法，17年将不会有很大的变动，所以在年后将会去进一步了解并决定。 这也是我去年搬家的时候对17年立的flag。希望会实现。<br>16年成长了很多，也学会了如何去承担一份感情。褪去了过去的幼稚，重新认识自己，看清自己，并去选择对方。一起走下去。</p>
</blockquote>
</li>
<li><p>有意思的东西</p>
<blockquote>
<p>上个周末，花了一点时间将之前自己的一个老应用接入了支付模块，这个系统一直以来都是免费提供给母校的学生使用的，但是慢慢的失去了很多开发的动力，因此<br>我决定花点时间将盈利加进去，刚更新那几天，每天100左右的收入是有的，当然我并没有多在乎一天能多钱。只是为了增加自己平时空闲时间去开发的动力。当然后面<br>还是降了下来，也让我意识到运营的重要性。之前自己一直都是扮演产品和开发的角色，后面增加支付，又得扮演运营的角色，最后还是证明的我不是做运营的料。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>2017</p>
<blockquote>
<p>2017年，也不说是新的开始了，因为有很多事情要一直做下去。</p>
<ol>
<li>这一年，我会花更多的时间在开源方面、自身技术的深度沉淀和公司的数据增长上，并继续向周围技术进行扩散。</li>
<li>买房、买车。。。。</li>
<li>那么是否考虑结婚呢。。。</li>
</ol>
</blockquote>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Tar包高优化解析]]></title>
      <url>https://xiyoumc.github.com/2017/01/21/TarParse/</url>
      <content type="html"><![CDATA[<h1 id="本文将介绍一个针对Tar包解析时的优化方案，旨在优化内存、提高效率。"><a href="#本文将介绍一个针对Tar包解析时的优化方案，旨在优化内存、提高效率。" class="headerlink" title="本文将介绍一个针对Tar包解析时的优化方案，旨在优化内存、提高效率。"></a>本文将介绍一个针对Tar包解析时的优化方案，旨在优化内存、提高效率。</h1><h3 id="一、首先讲一个tar包的文件结构。（懂得可以绕开此段）"><a href="#一、首先讲一个tar包的文件结构。（懂得可以绕开此段）" class="headerlink" title="一、首先讲一个tar包的文件结构。（懂得可以绕开此段）"></a>一、首先讲一个tar包的文件结构。（懂得可以绕开此段）</h3><pre><code>tar只是一个归档文件，并不进行压缩。
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">　　<span class="keyword">struct</span> tar_header</div><div class="line">　　&#123;</div><div class="line">　　 <span class="keyword">char</span> name[<span class="number">100</span>];</div><div class="line">　　 <span class="keyword">char</span> mode[<span class="number">8</span>];</div><div class="line">　　 <span class="keyword">char</span> uid[<span class="number">8</span>];</div><div class="line">　　 <span class="keyword">char</span> gid[<span class="number">8</span>];</div><div class="line">　　 <span class="keyword">char</span> size[<span class="number">12</span>];</div><div class="line">　　 <span class="keyword">char</span> mtime[<span class="number">12</span>];</div><div class="line">　　 <span class="keyword">char</span> chksum[<span class="number">8</span>];</div><div class="line">　　 <span class="keyword">char</span> typeflag;</div><div class="line">　　 <span class="keyword">char</span> linkname[<span class="number">100</span>];</div><div class="line">　　 <span class="keyword">char</span> magic[<span class="number">6</span>];</div><div class="line">　　 <span class="keyword">char</span> version[<span class="number">2</span>];</div><div class="line">　　 <span class="keyword">char</span> uname[<span class="number">32</span>];</div><div class="line">　　 <span class="keyword">char</span> gname[<span class="number">32</span>];</div><div class="line">　　 <span class="keyword">char</span> devmajor[<span class="number">8</span>];</div><div class="line">　　 <span class="keyword">char</span> devminor[<span class="number">8</span>];</div><div class="line">　　 <span class="keyword">char</span> prefix[<span class="number">155</span>];</div><div class="line">　　 <span class="keyword">char</span> padding[<span class="number">12</span>];</div><div class="line">　　&#125;;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>&gt;<br>　　以上是Tar中保存文件信息的数据结构，其后跟着的就是文件的内容。<br> size为文件大小的八进制字节表示，例如文件大小为90个字节，那么这里就是八进制的90，即为132。<br>　　其中，文件大小，修改时间，checksum都是存储的对应的八进制字符串，字符串最后一个字符为空格字符<br>　　checksum的计算方法为出去checksum字段其他所有的512-8共504个字节的ascii码相加的值再加上256(checksum当作八个空格，即8<em>0x20）<br>　　文件内容以512字节为一个block进行分割，最后一个block不足部分以0补齐<br>　　两个文件的tar包首先存放第一个文件的tar头结构，然后存储文件内容，接着存储第二个文件的tar头结构，然后存储文件内容<br>　　所有文件都存储完了以后，最后存放一个全零的tar结构<br>　　所有的tar文件大小应该都是512的倍数，一个空文件打包后为512</em>3字节，包括一个tar结构头，一个全零的block存储文件内容，一个全零的tar结构</p>
<ul>
<li>检测tar文件格式的方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1、检测magic字段，即在0x101处检查字符串，是否为ustar。有时某些压缩软件将这个字段设置为空。如果magic字段为空，进入第2步。</div><div class="line">2、计算校验和，按照上面的方法计算校验和，如果校验和正确的话，那么这就是一个tar文件。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：在windows下面，不支持uid、uname等，有的甚至不支持magic，这样就比较麻烦了。</p>
<h3 id="二、Java层普遍的“解压”方式"><a href="#二、Java层普遍的“解压”方式" class="headerlink" title="二、Java层普遍的“解压”方式"></a>二、Java层普遍的“解压”方式</h3><p>&gt;<br>     因为在jdk中提供了 FilterInputStream,因此我们可以通过继承该类，并构造一个TarEntry的模板，在子类中按每512个字节，将一个tar流分成包含N个512字节的TarEntry. 这样我们就可以将一个tar包通过TarInputStream和TarEntry解开到一个map集合中<entryname,data>.</entryname,data></p>
<h3 id="三、内存优化的-“解压”方式"><a href="#三、内存优化的-“解压”方式" class="headerlink" title="三、内存优化的 “解压”方式"></a>三、内存优化的 “解压”方式</h3><p>&gt;<br>     由于每一个TarEntry都是一个固定大小字节的对象，那么我们可不可以直接读取这块内存，而不是将所有都常驻内存呢？<br>     答案当然是可以的。<br>    为了内存上的优化和效率上的提升，我们可以直接读取指定EntryNam的内存块。<br>    因为一个tar包基本的组成结构就是   entryName-&gt;data。我们可以拿到每一个EntryName和其对应的内存大小、偏移量，在读取的时候直接在TarInputStream中读取相应内存块。<br>   代码如下：</p>
<ol>
<li><p>一个简单维护TarEntry偏移量和字节大小的类McTarEntry。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">McTarEntry</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">long</span> offset;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">McTarEntry</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">      offset = builder.offset;</div><div class="line">      size = builder.size;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getOffset</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> offset;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> size;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">      <span class="keyword">private</span> <span class="keyword">long</span> offset = <span class="number">0</span>;</div><div class="line">      <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">offset</span><span class="params">(<span class="keyword">long</span> offset)</span> </span>&#123;</div><div class="line">          <span class="keyword">this</span>.offset = offset;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">size</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">          <span class="keyword">this</span>.size = size;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">public</span> H5TarEntry <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">new</span> McTarEntry(<span class="keyword">this</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>解析Tar包，将每个McTarEntry保存在map</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(tarPath);</div><div class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</div><div class="line">TarInputStream tis = <span class="keyword">new</span> TarInputStream(bis);</div><div class="line">TarEntry te = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">while</span> ((te = tis.getNextEntry()) != <span class="keyword">null</span>) &#123;</div><div class="line">    String entryName = te.getName();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (te.isDirectory() || TextUtils.isEmpty(entryName)) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    McTarEntry mcTarEntry = <span class="keyword">new</span> McTarEntry.Builder().offset(tis.getCurrentOffset())</div><div class="line">            .size((<span class="keyword">int</span>) te.getSize()).build();</div><div class="line"></div><div class="line">    tarEntryMap.put(entryName, h5TarEntry);</div><div class="line"></div><div class="line">&#125;</div><div class="line">tis.close();</div></pre></td></tr></table></figure>
</li>
<li><p>读取指定entryName的数据块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] get(String appId, String entryName) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          <span class="keyword">byte</span> buffer[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</div><div class="line">          <span class="keyword">int</span> count;</div><div class="line">          ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">          <span class="keyword">if</span> (!tarEntryMap.containsKey()) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">long</span> offset = tarEntryMap.get(entryName).getOffset();</div><div class="line">          <span class="keyword">int</span> entrySize = tarEntryMap.get(entryName).getSize();</div><div class="line">          FileInputStream fis = <span class="keyword">new</span> FileInputStream(tarPath);</div><div class="line">          BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</div><div class="line">          TarInputStream tis = <span class="keyword">new</span> TarInputStream(bis);</div><div class="line">          H5Log.d(TAG, <span class="string">"entryName"</span> + entryName + <span class="string">" skip offset:"</span> + offset + <span class="string">" size"</span> + entrySize);</div><div class="line">          tis.skip(offset);</div><div class="line">          <span class="keyword">if</span> (buffer.length &gt; entrySize) &#123;</div><div class="line">              buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[entrySize];</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">int</span> bufferSize = <span class="number">0</span>;</div><div class="line">          <span class="keyword">while</span> ((count = tis.read(buffer)) != -<span class="number">1</span>) &#123;</div><div class="line">              bos.write(buffer, <span class="number">0</span>, count);</div><div class="line">              bufferSize += count;</div><div class="line">                 <span class="comment">// 当前buffer加上已经读取的bufferSize如果超过entrySize那么我们就应该重新计算buffer进行最后一次读取。</span></div><div class="line">              <span class="keyword">if</span> ((bufferSize + buffer.length) &gt; entrySize) &#123;</div><div class="line">                  buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[entrySize % bufferSize];</div><div class="line">                  bufferSize = entrySize - entrySize % bufferSize;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (buffer.length == entrySize || entrySize == bufferSize) &#123;</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          tis.close();</div><div class="line">          <span class="keyword">byte</span>[] data = bos.toByteArray();</div><div class="line">          <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">          &#125;</div><div class="line">          H5Log.d(TAG, <span class="string">"entryName:"</span> + entryName);</div><div class="line">          <span class="keyword">return</span> data;</div><div class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">          H5Log.e(TAG, <span class="string">"exception :"</span> + e);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>  这样就可以通过指定的entryName，根据其offset和 size 计算到这个entry在TarStream中固定内存块，从而拿到真正的数据。</p>
</li>
</ol>
<h3 id="总结：两种读取方式的区别："><a href="#总结：两种读取方式的区别：" class="headerlink" title="总结：两种读取方式的区别："></a>总结：两种读取方式的区别：</h3><ul>
<li>第一种<br>优点：减少了I/O操作。<br>缺点：耗费了内存。假如一个很大的资源在这个tar中，但是被使用的概率很低，这样耗费了内存从而不值得这么做。</li>
<li>第二种<br>优点：节省了内存，提高了读取效率<br>缺点：增加了I/O操作，Tar资源可能存在被篡改的风险。</li>
</ul>
<p>Thanks.<br>  By MC.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[最近心烦]]></title>
      <url>https://xiyoumc.github.com/2016/12/19/%E6%9C%80%E8%BF%91%E5%BF%83%E4%BA%8B/</url>
      <content type="html"><![CDATA[<p>不知道自己是将工作带到了生活还是生活带到了工作。。。<br><a id="more"></a></p>
<blockquote>
<p>最近事真的很多，也导致了自己事很多。 </p>
<p>喜欢的人，自己变得约束力越来越多。这不是我要的。<br>我很想放放松松的恋爱。 最近对你一直很闹脾气，动不动就闹脾气。  我想我是该冷静冷静了。<br>让我们开开心心的恋爱下去吧。  一直。相爱。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[戒烟]]></title>
      <url>https://xiyoumc.github.com/2016/10/26/%E6%88%92%E7%83%9F/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/xiyouMc/xiyoumc.github.io/blob/master/images/timg.jpeg?raw=true" alt=""><br>以后每天都会在这里记录，戒烟史！<br><a id="more"></a><br>GoGoGo</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大姨夫]]></title>
      <url>https://xiyoumc.github.com/2016/10/25/%E5%A4%A7%E5%A7%A8%E5%A4%AB/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/xiyouMc/xiyoumc.github.io/blob/master/images/big.jpg?raw=true" alt=""><br>最近又开始胡思乱想，针对感情、爱情总是一段时间就害怕会分开。特么的都是自己作死。哈哈哈<br><a id="more"></a><br>有一种大姨夫的感觉，有一种小女人的心思，有一种想狠狠抱着你的想法。<br>这是病，得治。自己胡思乱想，想的多，多听听歌吧。<br>大家都很忙，过好自己，照顾好爱的人。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[憧憬]]></title>
      <url>https://xiyoumc.github.com/2016/09/07/Home/</url>
      <content type="html"><![CDATA[<blockquote>
<p>时常在憧憬未来 、未来 家的样子</p>
</blockquote>
<p><img src="https://github.com/xiyouMc/xiyoumc.github.io/blob/master/images/home.jpg?raw=true" alt="zls"></p>
<a id="more"></a>
<blockquote>
<ul>
<li>一直都想有个家、有自己的妻儿</li>
<li>有一个可以依靠、也可以安心的家</li>
<li>So 让我们一起努力。有一天你会是我的妻子，我会是你的丈夫，你我会是孩子的父母。</li>
</ul>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Alison]]></title>
      <url>https://xiyoumc.github.com/2016/09/07/Alison/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Baby, You Complete Me.<br><a id="more"></a></p>
<ul>
<li>Hey there,sexy lady</li>
<li>I`m loving what you do</li>
<li>I`m thinking so are you</li>
<li>You`re trying to dent it</li>
<li>But I know I changed your mind</li>
<li>And please don`t try to fight it</li>
<li>Cause I know that you`ll be mine</li>
<li>Be mine.</li>
<li>I want you,baby</li>
<li>Come get it,girl</li>
<li>I need you,baby</li>
<li>I`m on you,girl</li>
</ul>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[You are My Sunshine.]]></title>
      <url>https://xiyoumc.github.com/2016/09/02/Sun/</url>
      <content type="html"><![CDATA[<p>我喜欢温暖、你恰好是太阳<br><a id="more"></a></p>
<blockquote>
<p>时间流逝<br>忙碌的项目开发，无数的接口，无数的调试<br>Github也好久没更新<br>不过。。。<br>不过。。。最开心 幸福的事是拥有了你<br>我喜欢温暖、你恰好是太阳</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[爱情观]]></title>
      <url>https://xiyoumc.github.com/2016/08/18/Lover/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/xiyouMc/xiyoumc.github.io/blob/master/images/shelizi.png?raw=true" alt="zls"></p>
<p>诸心，皆为非心 心中无物、无心，便是真心<br><a id="more"></a></p>
<ul>
<li>佛教劝人学习放下万缘，不要执着感情，却不是要人无情，因为，人本来就是有情众生，只要把爱情的聚散当成因缘变化来看，明白“缘散则散，缘聚则聚”的道理，爱、恨便能在这一念之间转变、释怀。只要是人，就不可能没有感情，佛教称众生为“有情”，就是因为“有爱”的缘故。人活在世界上，除了饮食的养分，还需要精神的滋润，而感情就是最好的精神滋润剂，因此，感情和生命可说是息息相关的。感情虽然带给人很多温暖，却也充满痛苦；相爱的人，感情浓烈，如胶似漆分不开，一旦爱过了头，或失去了爱，就变成了苦；也有人以为只要不动情，就不会为爱所苦，这恐怕是一厢情愿的想法，既然情爱和生命息息相关，无论是否定它，或硬生生地把它切断，既不合乎佛法的因果，也不合乎人情的道理。佛教虽然劝人学习放下万缘，不要执着感情，却不是要人无情，因为，人本来就是有情众生。</li>
</ul>
<ul>
<li>遇上触礁的爱情<blockquote>
<p>然而，男女间的感情，往往非自己的期待所能控制。假如有一天，你的女朋友或是男朋友突然跟你说：“对不起！我已经遇到更适合的人，请你以后不要再来找我。”你会不会觉得晴天霹雳？觉得自己被背叛、被抛弃了？失恋的人，常常悲观地觉得生不如死：“连我最爱的人都不要我了，我还活下去做什么？” 有时候甚至还会骂说：“哼！你不要我，我本来就不想要你了。”或是“真是有眼无珠。”<br>有人为情轻生，结束自己的生命；有人为情杀人，抱着“你让我这样痛苦，我也不让你快活”；或是“我得不到你，天下人也甭想得到你”的偏激心理，而把对方杀了，甚至有的在杀了对方之后，自己也跟着自杀。大多数的人都知道，爱情是双向的，既然如此，如果对方不爱你，就不要苦苦追求不舍，应该知趣地离开，可是，有些人偏偏就是死心眼，非卿不娶，非君不嫁，不但为对方带来困扰，也让自己陷入困境。话虽这么说，毕竟人非草木，谁能无情？一般的人，仍常常为情所苦，可见得要放下感情，其实是件很不容易的事。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>以因缘观化解爱恨* </p>
<blockquote>
<p>因爱而生怨、生恨是很不幸的，从佛法的观点来看，这些都是愚痴的行为，因为真正的爱情要双方你情我愿，有因有缘才能成就，不是自己想要就要。假使对方已经明白拒绝你的感情，自己却还想尽办法，想把对方追回来；就好像赌输的人一样，心中不服气，老是想翻本，钱输光了就想办法再借，也因而愈陷愈深，不可自拔，既然知道无法挽回，就不要再陷下去了，应该赶快撤退，就算是以此为戒，至少学到经验，也就够了，这样就是对自己慈悲。慈悲不仅是照顾别人，事实上，也是在保护自己。当爱情受到挫折时，应试着化解自己心中的愤怒、不平。佛法当中“空”的观念，是最能够助人摆脱痛苦的。只要把爱情的聚散当成因缘变化来看，明白“缘散则散，缘聚则聚”的道理，爱、恨便能在这一念之间转变、释怀。</p>
</blockquote>
</li>
<li><p>陷入痛苦的爱情</p>
<blockquote>
<p>为什么爱情要俘虏人呢？很多情侣往往会说：“我爱你爱得要死！”或是喜欢说：“我是你的一半，你是我的一半！” 明明是不同的两个人，却彼此互相要求对方，成为自己的一部分，这种“爱”，都希望既要俘虏对方的人，也要俘虏对方的心；控制他的行动，还要控制他的心。所谓“俘虏”，其实就是占有，就是把自我价值扩展到他人身上。男女间的爱，本来就是一种互相的占有。你想占有他，他也想占有你，因为都想占有，所以就分不开了，这样的“爱”，到头来，却只让对方更想逃走。<br>此外，很多人谈恋爱，其实是想找个依靠，也就是找“靠山”的心态。我要靠我的男朋友、我要靠我的女朋友、我要靠我的丈夫、我要靠我的太太，刚开始，依赖一下、靠一靠，可能觉得很温馨。可是，靠久了，对方可能就会想：“怎么老是要靠我？我好累喔！” 偶尔靠一靠是甜蜜的，但老是靠着，就会成了对方的麻烦和负担。即使在爱情的两人世界中，每个人都还是独立的自我，不管是男的还是女的，每个人都怕别人变成自己的负担，如果不能够独立，只想要依靠或是指望另一半，就会成了对方的包袱。</p>
</blockquote>
</li>
<li><p>以尊重的心态经营爱情</p>
<blockquote>
<p>真正的爱情应该是无私的付出，但是多半的爱情还是以占有、控制为出发点，这和人的不安全感有关，因此，要求情人对你做到全心的奉献，恐怕是很困难的事。也因如此，甜蜜的爱情，却往往是最痛苦的。期待、要求，希望得到对方“真心”的对待和付出，可是，这种心是“真心”吗？《金刚经》中有一段话：“如来说诸心，皆为非心，是名为心。”“诸心”，是指每一个众生的种种心理活动现象，这些都是虚妄的，从佛法的观点来看，只要有心，就都不是真心，要“心无所住”，心中无物、无心，那才是“真心”。所以说，占有心、依靠心、期待心，都不叫“真心”，而是“烦恼心”。</p>
</blockquote>
</li>
<li><p>古人说“相敬如宾”，虽是老生常谈，却是能够维系长久爱情的真正智慧。如果想避免吵架、误解，或者是想消融不断的期待、要求，在遇到诸如此类的问题时，不妨以尊重的心态，心悦诚服、欢欢喜喜、平平静静去面对、解决，心中的纠结，其实在当下都能即得化解。爱情里的关系，并不是在互相执着、纠缠和占有，而是互相的贡献、成长和学习。能够互相关怀、照顾、包容，去彼此计较、相互猜疑，多沟通，并相互信赖，才能成为菩萨伴侣。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从0开始Github系列教程一  开门]]></title>
      <url>https://xiyoumc.github.com/2016/08/18/%E4%BB%8E0%E5%BC%80%E5%A7%8BGithub%E4%B8%80/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/4653472-2bd1a717e57c76f3?imageMogr2/auto-orient/strip" alt=""></p>
<p>这是一套Github的小白教程<br><a id="more"></a></p>
<h3 id="本文来自我的公众号：DeveloperPython"><a href="#本文来自我的公众号：DeveloperPython" class="headerlink" title="本文来自我的公众号：DeveloperPython"></a>本文来自我的公众号：DeveloperPython</h3><p><img src="http://upload-images.jianshu.io/upload_images/4653472-2bd1a717e57c76f3?imageMogr2/auto-orient/strip" alt=""><br>对于Github,我相信很多人都不陌生，并且我也一直认为Github是程序员的必备，当然还有一个 StackOverFlow。</p>
<p>但是在我周围、包括公号里面的读者，大部分都不怎么使用Github。</p>
<p>因为上次我的项目被点赞到Github Trending之后（全球开源项目的热门），我发现很多点赞的国内开发者都是不怎么使用Github的。因为几乎看不到他们的代码提交记录，然而里面很多国外开发者的点赞，我再进入他们的主页，大部分开发者都是持续提交代码中。</p>
<p>之后我也收到好多消息，希望我写一篇关于Github的教程或者如何上Trending。</p>
<p>其实，我接触Github时间挺早的了，大概在上大学开始写代码的时候，就已经使用上了 Github。当时我也是只下载，不用的那种。大概在接触 Github 一年左右之后，我就开始深入使用。</p>
<p>到目前为止，自己 Github 中的项目已经有了130多个。</p>
<p><a href="https://www.github.com/xiyouMc/" target="_blank" rel="external">https://www.github.com/xiyouMc/</a> </p>
<p>Github是一个开源、开放、免费的平台，它更多的是提供给我们学习和贡献的。</p>
<p>所以我决定写一个系列来讲解如何去更好的使用Github，为了让国内的开发者能合理的使用Github。</p>
<h2 id="01、什么是-Github"><a href="#01、什么是-Github" class="headerlink" title="01、什么是 Github"></a>01、什么是 Github</h2><p>Github其实是一家公司，坐落在旧金山。是由三个知名的开发者在08年创办的，具体是谁就不用讲了，讲了也记不住。</p>
<p>这是它的 Logo:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4653472-a9a0ffeb0f3deb93?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>大概也就在08年4月多，正式上线。</p>
<p><a href="https://www.github.com/" target="_blank" rel="external">https://www.github.com/</a> </p>
<p>简单的来讲，Github是一个基于 Git 的版本托管平台。</p>
<p>大概在13年的时候，Github 用户数量已经破300万，到目前为止我想也应该上千万了吧。</p>
<p>因此它有一个很洋气的名字就是全球最大同性交友平台。GayHub。</p>
<h2 id="02、Github、Gitlab-和-Git-的区别"><a href="#02、Github、Gitlab-和-Git-的区别" class="headerlink" title="02、Github、Gitlab 和 Git 的区别"></a>02、Github、Gitlab 和 Git 的区别</h2><p>这个问题，我相信很多人都分不清。</p>
<p>有的人会把Git理解成Github。你会经常听到有人跟你讲：“你可以去Git上找下，看看有没有你想要的代码”。 如果这句话，是别人跟我讲的，那我绝对是一脸懵逼的。</p>
<p>至于为什么，那么我就来详细讲下这三个的区别。</p>
<p><strong>先说下Git</strong></p>
<p>Git是一款免费、开源的分布式版本控制系统，他是由著名的Linux发明者 Linus Torvalds 开发的。</p>
<p>所以说Git是一个版本的控制系统，而非一个平台。</p>
<p>提到这个版本控制系统，大家可能会想到SVN，毕竟这是很多大学都让学生使用的东西。只不过Git是新时代的产物。</p>
<p>如果在15年的时候，你告诉我你们在使用SVN，那么还情有可原。毕竟那时候很多大公司还在用SVN，比如支付宝。但到现在了，你还在使用SVN那么真的是太落伍了。</p>
<p>所以不管是学习Github，或者从事编程行业，Git绝对算是必备技能。</p>
<p><strong>接下来说Github</strong></p>
<p>上面已经说过，Github 是基于Git的版本托管服务。所以Git对于Github来讲就是一个版本管理的工具。</p>
<p>其次Github，还有更多的功能，毕竟它是一个平台。后面的文章中，我也会列举出重要的几个。</p>
<p><strong>最后来讲讲Gitlab</strong></p>
<p>这个东西呢，其实是<strong>企业内部</strong>的Github。</p>
<p>因为Github毕竟是一个开源的、全球性的代码托管平台。</p>
<p>对于企业来讲，他们更希望内部有个这样类似的Git代码托管服务。所以他们会选择Gitlab，这个开源的代码托管平台。</p>
<p>而且Gitlab一直在更新版本，目前已经到了9.1版本。</p>
<p><a href="https://github.com/gitlabhq/gitlabhq/" target="_blank" rel="external">https://github.com/gitlabhq/gitlabhq/</a></p>
<p>从地址来看，你也会发现Gitlab是Github平台上的一个开源项目，这样也就不难理解这两个的区别了。</p>
<h2 id="03、Github-的影响力"><a href="#03、Github-的影响力" class="headerlink" title="03、Github 的影响力"></a>03、Github 的影响力</h2><p>我可以这么说吧，只要你能想到的大公司，他们都会在Github上有一个组织来贡献内部的优秀代码和框架。</p>
<p>比如：<br>Google: <a href="https://www.gihutb.com/google" target="_blank" rel="external">https://www.gihutb.com/google</a><br>Apple: <a href="https://www.github.com/apple/" target="_blank" rel="external">https://www.github.com/apple/</a><br>Facebook: <a href="https://www.github.com/facebook/" target="_blank" rel="external">https://www.github.com/facebook/</a><br>Alibaba: <a href="https://www.github.com/alibaba" target="_blank" rel="external">https://www.github.com/alibaba</a><br>….<br>还有全球顶级的项目，也同样在Github。<br>Linux: <a href="https://www.github.com/torvalds/linux" target="_blank" rel="external">https://www.github.com/torvalds/linux</a><br>Nodejs: <a href="https://www.github.com/nodejs/node" target="_blank" rel="external">https://www.github.com/nodejs/node</a><br>Weex: <a href="https://github.com/alibaba/weex" target="_blank" rel="external">https://github.com/alibaba/weex</a><br>等等的….<br>同样还有全球顶尖级的开发者。<br>Linux之父 Linus:<br><img src="http://upload-images.jianshu.io/upload_images/4653472-b3a42f0dacbef2cd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>Android 之神 Jake:<br><img src="http://upload-images.jianshu.io/upload_images/4653472-e0d5bf0e4644d3cc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>等等的，我就不一一列举了。</p>
<p>只要是在编程届厉害的人物，都会出现在Github。</p>
<p>并且很多牛逼的项目做开源，比如你某天听说了某个公司的xx框架开源了。那么它们绝对在Github上开源的。</p>
<p>因此，Github已经是开源的代名词。</p>
<h2 id="04、Github能做什么"><a href="#04、Github能做什么" class="headerlink" title="04、Github能做什么"></a>04、Github能做什么</h2><ul>
<li><strong>优秀的开源项目</strong></li>
</ul>
<p>学好使用优秀的开源项目，是一个可以避免你在软件开发中重复造轮子的事情。</p>
<p>确切的来讲，正是因为有个Github上优秀的开源项目，才促使了我们在软件开发中变得越来越容易、越来越快速。</p>
<p>比如说：网络请求库、图片加载库。如果让你去自己实现，那么时间和资源是一个很大的成本。对于大公司，可能在人力和资源上是充沛的。但是对于大部分互联网来讲时间就是一切。</p>
<p>所以在使用开源项目的同时，学习他们优秀的设计思想和实现方式，无疑是提升自我编程能力的好时机。</p>
<p>同样的，如果你能拥有一个优秀的开源项目，那么绝对是一个很好的体验。</p>
<p>比如说我开源的WebHubBot，当你看到自己的项目每天每时都有人在点赞，那种感觉真心是比朋友圈被点赞爽很多倍的！！！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4653472-b63084401d16c5a5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/4653472-a4be03a4fa7183b0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li><strong>多人协作</strong><br>其实多人协作对于Github来讲无疑是一个转折点。</li>
</ul>
<p>因为一个好的项目，绝非几个人就能搞定的，因此Github提供了很好的协作平台。</p>
<p>当你把代码提交上去之后，你可以让其他人和你一同开发，或者说如果你的项目很好，全球的开发者都会给你的项目做贡献。</p>
<p>以我为例，前段时间提交了一个很有意思的项目，之后就收到了好几个全球开发者代码贡献，如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4653472-668e59895e243bdb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>因此，多人协作真心是一个很爽、很棒的功能。</p>
<ul>
<li><strong>其次就是搭建个人网站</strong></li>
</ul>
<p>Github Pages是Github提供的一套完整的博客搭建环境。</p>
<p>平时你会发现很多人的个人博客域名都是xxxx.github.io。这就是使用Github Pages来搭建的。使用方法很简单，也绝对是一个装逼利器。</p>
<ul>
<li><strong>个人简历</strong></li>
</ul>
<p>活跃的Github账号，是一个很好的个人简历。</p>
<p>据我所知，目前很多猎头和公司的HR都很喜欢逛Github。</p>
<p>并且很多国外的科技公司也都会通过Github来寻找优秀的人才。</p>
<p>所以多用Github，会让你收到很多意外的惊喜。</p>
<h2 id="05、加入Github"><a href="#05、加入Github" class="headerlink" title="05、加入Github"></a>05、加入Github</h2><p>相信大家读到这里，都迫不及待的想去使用Github了。</p>
<p>那么事不宜迟，从现在开始，快去注册一个Github账号。 </p>
<p>链接： <a href="https://www.github.com/" target="_blank" rel="external">https://www.github.com/</a> 。</p>
<p>注册完成之后，先玩着，了解下整个平台的功能。</p>
<p>同时也可以试着搜索下我的Github：<br>ID：xiyouMc<br><a href="https://www.github.com/xiyouMc" target="_blank" rel="external">https://www.github.com/xiyouMc</a> </p>
<p>接下来，我还会继续连载Github一系列的文章。</p>
<p>保证你们看完之后，会有不一样的收获。</p>
<p>同时如果你目前在使用Git或者Github中，那么有问题的话，也同样可以给我留言，我会一一给你们解答。</p>
<p>——<br>扫描二维码，关注公众号<br><img src="http://upload-images.jianshu.io/upload_images/4653472-1c1e06e2f58b0610?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>生活不止眼前的苟且，还有手下的代码、<br>和嘴上的扯淡<br>——<br>个人博客: <a href="http://xiyoumc.0x2048.com/" target="_blank" rel="external">http://xiyoumc.0x2048.com/</a><br>Github:<a href="https://www.github.com/xiyouMc" target="_blank" rel="external">https://www.github.com/xiyouMc</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hybrid调试指南]]></title>
      <url>https://xiyoumc.github.com/2016/08/17/hybrid%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/xiyouMc/HybridApp/blob/master/%20hybrid.png?raw=true" alt="inspect1"></p>
<h1 id="Hybrid调试指南"><a href="#Hybrid调试指南" class="headerlink" title="Hybrid调试指南"></a>Hybrid调试指南</h1><blockquote>
<p>开发接口过程中如何自测接口?</p>
</blockquote>
<a id="more"></a>
<h2 id="Dependency"><a href="#Dependency" class="headerlink" title="Dependency"></a>Dependency</h2><blockquote>
<ul>
<li>Chrome</li>
<li>Android SDK Level &gt;=19</li>
</ul>
</blockquote>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><blockquote>
<ul>
<li>Android设备连接电脑，并打开USB调试</li>
<li>通过Hybrid打开任意页面</li>
<li>使用Chrome浏览器打开，<a href="chrome://inspect" target="_blank" rel="external">chrome://inspect</a>,  调用JSBridge对应的接口</li>
</ul>
</blockquote>
<h2 id="Picture"><a href="#Picture" class="headerlink" title="Picture"></a>Picture</h2><blockquote>
<ul>
<li>以下是 “隐藏TitleBar”为例，通过JSBridge来隐藏Native的标题栏</li>
</ul>
</blockquote>
<ul>
<li>打开Console控制台</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiyouMc/HybridApp/master/images/inspect1.png" alt="inspect1"></p>
<ul>
<li>注入JSBridge.call(“hideTitlebar”);</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiyouMc/HybridApp/master/images/inspect2.png" alt="inspect2"></p>
<ul>
<li>App端隐藏掉Titlebar</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiyouMc/HybridApp/master/images/hideTitlebar.png" alt="hideTitle"></p>
<ul>
<li>通过Hybrid打开任意页面，测试页面-Slideplus素材中心页</li>
<li>使用Chrome浏览器打开，<a href="chrome://inspect" target="_blank" rel="external">chrome://inspect</a></li>
</ul>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><p>&gt;</p>
<ul>
<li>JSBridge.call(“hideTitlebar”)  —Hide Title bar</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[插件化框架简介]]></title>
      <url>https://xiyoumc.github.com/2016/05/05/%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>本框架是建立在 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-load-apk</a>进行的上层封装。增加插件动态加载到libs目录和针对模块Service的注入。</p>
<p>本文将以H5Core为插件进行讲解。</p>
<h5 id="更新日志："><a href="#更新日志：" class="headerlink" title="更新日志："></a>更新日志：</h5><p>&gt;</p>
<ul>
<li>2016/7/6  commit -m “增加懒加载功能”   hash: 2a335dc49654c80fb6779cacefdf3ed712c23a8</li>
</ul>
<h1 id="插件化框架简介"><a href="#插件化框架简介" class="headerlink" title="插件化框架简介"></a>插件化框架简介</h1><ul>
<li>插件化是将Apk中功能类似的模块封装到独立的Application中，并根据框架约定好的规则完成Apk的动态加载和Service的注入。</li>
<li>本框架是将每一个Apk作为so并使用定制化打包脚本将so文件打到主Project/libs/jniLibs，这样在apk编译的时候就可以将so文件直接装载进data/data/xxxxx/lib目录，支持后续的DexClassLoader加载该文件。</li>
<li>每一个模块分为Api和Core，Api作为模块对外提供的接口，Core作为封装好的独立模块，每一个模块做好自己的混淆。注入操作需在Core中定义，下文将介绍这块。</li>
<li><p>主Client增加bundleList.config文件，文件配置：</p>
<pre><code>bundleName=h5core    //直接加载的插件
lazyBundle=h5core.H5Service&amp;H5Api //懒加载插件
</code></pre></li>
</ul>
<h2 id="一、Framework"><a href="#一、Framework" class="headerlink" title="一、Framework"></a>一、Framework</h2><ul>
<li>Framework提供了一个动态加载apk的框架，并提供一个加载独立模块的BaseMateinfo。</li>
</ul>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol>
<li>开发模块时需要在  module(core)/package name/下定义Metainfo继承自BaseMateinfo。 这样该模块在主Apk安装的时候就会动态将模块的接口注入到框架，后续提供给其它组件调用。</li>
<li><p>模块提供的主要方法类有:BasePluginActivity,BasePluginFragmentActivity,BasePluginService,BaseMateinfo,MarkApplication.</p>
<pre><code>BasePluginActivity: 基础的Activity，每一个模块中的Activity都需要继承该类，完成模块中的Activity的代理化。
BasePluginFragmentActivity： 基础的FragmentActivity，同上。需要继承该类
BasePluginService: 基础的Service，同上。
BaseMateinfo: 模块Service注入的基类，其它模块的Core层都需要定义一个Metainfo来继承该类，并完成Service的注入。（后面会介绍如何注入）
MarkApplication:模块的Application，可以拿到模块的Context，并提供查找Service，启动Activity等方法。
</code></pre></li>
</ol>
<h2 id="二、Activity层"><a href="#二、Activity层" class="headerlink" title="二、Activity层"></a>二、Activity层</h2><ul>
<li>为了让proxy全面接管apk中所有activity的执行，需要为activity定义一个基类BaseActivity，在基类中处理代理相关的事情，同时BaseActivity还对是否使用代理进行了判断，如果不使用代理，那么activity的逻辑仍然按照正常的方式执行，也就是说，这个apk既可以按照执行，也可以由宿主程序来执行。</li>
</ul>
<h3 id="独立模块架构"><a href="#独立模块架构" class="headerlink" title="独立模块架构"></a>独立模块架构</h3><ul>
<li>模块分类：Api和Core,针对不同业务可追加前缀。</li>
<li>每一个模块对外提供一个Service供其他模块引用。Service的Interface类放在Api模块，实现类放在Core。实现独立模块的封装。</li>
<li><p>Service注册：在Core的根包目录创建MetaInfo类，继承Framework模块的BaseMetaInfo.如下：</p>
<pre><code>public class MetaInfo extends BaseMetaInfo {
private static final String TAG = &quot;MetaInfo.Init&quot;;
public MetaInfo() {
    Log.d(TAG,&quot;Service init&quot;);
    ServiceDescription serviceDescription = new ServiceDescription();
    serviceDescription.setInterfaceName(XXService.class.getName());
    serviceDescription.setClassName(XXServiceImpl.class.getName());
    services.add(serviceDescription);
}
}
注解:
ServiceDescription类是针对Service的描述类，将接口和实现封装在该对象，并将其添加到services列表中。
</code></pre><p>  以上工作就完成了模块的注入。</p>
</li>
</ul>
<h3 id="模块之间依赖"><a href="#模块之间依赖" class="headerlink" title="模块之间依赖"></a>模块之间依赖</h3><ul>
<li>模块只要是通过Api包的依赖进行访问。由于Api是作为一个Jar存在的，因此可以直接被其它模块依赖，并切记使用 provided来依赖，防止Api的jar包被编译进模块。</li>
<li><p>模块之间访问：主要的类有MarkApplication、MicroApplicationContext。</p>
<pre><code>比如其他模块访问Core:
XXService xxservice = MarkApplication.getInstance().getMicroApplicationContext().findServiceByInterface(XXService.class.getName());
这样就可以拿到容器的Service，从而调用其提供的方法。
</code></pre></li>
</ul>
<h3 id="模块内部资源的访问"><a href="#模块内部资源的访问" class="headerlink" title="模块内部资源的访问"></a>模块内部资源的访问</h3><ul>
<li><p>由于每一个模块作为独立的apk打入主apk,因此访问该apk的上下文不再是该apk的，而是框架层的代理上下文。</p>
<pre><code>示例：
1、Resourse获取
    MarkApplication.getInstance().getMicroApplicationContext().getResourcesByBundle(&quot;xxcore&quot;);
2、Assets获取
    MarkApplication.getInstance().getMicroApplicationContext().getAssetsByBundle(&quot;xxcore&quot;);
</code></pre></li>
</ul>
<h3 id="Gradle打包命令详解"><a href="#Gradle打包命令详解" class="headerlink" title="Gradle打包命令详解"></a>Gradle打包命令详解</h3><ul>
<li>gradle build ：编译当前模块。</li>
<li>gradle buidleJar:针对本模块生成jar包，保存目录在  xxx/build/libs/xxxx.jar</li>
<li>gradle uploadArchives:上传本项目包到Nexus服务器，提供给其他模块依赖</li>
</ul>
<p>例子：</p>
<p>1、Api包的<a href="https://github.com/xiyouMc/AppDynamicFramework/blob/master/API.MD" target="_blank" rel="external">build.gradle模版</a><br>2、Core包的 <a href="https://github.com/xiyouMc/AppDynamicFramework/blob/master/CORE.MD" target="_blank" rel="external">build.gradle模版</a></p>
<h2 id="三、依赖关系介绍"><a href="#三、依赖关系介绍" class="headerlink" title="三、依赖关系介绍"></a>三、依赖关系介绍</h2><ul>
<li>如今模块化之后，依赖关系的复杂度也相比之前复杂了不少，因此梳理好依赖关系是必须考虑的问题。</li>
</ul>
<h3 id="模块化主要的依赖关系："><a href="#模块化主要的依赖关系：" class="headerlink" title="模块化主要的依赖关系："></a>模块化主要的依赖关系：</h3><pre><code>框架主要有Portal、Framework、Module三个模块：
1、Portal是项目的Launcher目录。
2、Framework是框架的架构模块。
3、Module是每一个模块，并分为Api和Core，并且Api作为Android.library、Core作为Android.application.
4、每一个模块通过依赖其它模块的Api进行组件的调用。并且每一个Core都需要依赖Framework。
</code></pre><h3 id="插件apk的开发规范"><a href="#插件apk的开发规范" class="headerlink" title="插件apk的开发规范"></a>插件apk的开发规范</h3><p>开发插件apk所需要遵循的规范：</p>
<p><del>1. 不能用this：因为this指向的是当前对象，即apk中的activity，但是由于activity已经不是常规意义上的activity，所以this是没有意义的</del></p>
<p><del>2. 使用that：既然this不能用，那就用that，that是apk中activity的基类BaseActivity中的一个成员，它在apk安装运行的时候指向this，而在未安装的时候指向宿主程序中的代理activity，anyway，that is better than this.</del></p>
<p><del>3. 不能直接调用activity的成员方法：而必须通过that去调用，由于that的动态分配特性，通过that去调用activity的成员方法，在apk安装以后仍然可以正常运行。</del></p>
<ol>
<li>启动新activity的约束：启动外部activity不受限制，启动apk内部的activity有限制，首先由于apk中的activity没注册，所以不支持隐式调用，其次必须通过BaseActivity中定义的新方法startActivityByProxy和startActivityForResultByProxy，还有就是不支持LaunchMode。</li>
<li>目前暂不支持Service、BroadcastReceiver等需要注册才能使用的组件。</li>
</ol>
<h2 id="四、更新功能"><a href="#四、更新功能" class="headerlink" title="四、更新功能"></a>四、更新功能</h2><ul>
<li><p>2016/7/6 懒加载功能</p>
<pre><code>1、bundleList.config 文件增加lazyBundle字段来标示是否进行懒加载。字段值格式：bundleName.bundleService*bundleService。这样在该插件被调用的时候，框架采取load这个dex。    
2、优化效果：681kb的so，首次启动懒加载优化100ms。
</code></pre></li>
</ul>
<p>Thankd for your reading, by Mc…    Thanks Dynamic-load-apk</p>
<p>update</p>
<h2 id="Contact-me"><a href="#Contact-me" class="headerlink" title="Contact me"></a>Contact me</h2><p>Any further question?</p>
<p><a href="mailto:tmac694449212@gmail.com" target="_blank" rel="external">Email</a> me please!</p>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><pre><code>Copyright 2016 xiyouMc

Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
</code></pre>]]></content>
    </entry>
    
  
  
</search>
