<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Python新手引导第二篇]]></title>
      <url>https://xiyoumc.github.com/2017/03/06/Python%E6%96%B0%E6%89%8B%E5%BC%95%E5%AF%BC%20%E7%AC%AC%E4%B8%89%E7%AF%87%20Python%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h1 id="Python新手引导-第三篇-Python基础"><a href="#Python新手引导-第三篇-Python基础" class="headerlink" title="Python新手引导 第三篇 Python基础"></a>Python新手引导 第三篇 Python基础</h1><blockquote>
<p>###阅读本文需要4.66分钟</p>
</blockquote>
<a id="more"></a>
<p>有其他计算机语言基础的同学，阅读本篇基础部分建议1到2分钟。</p>
<ol>
<li>基础类型和变量</li>
<li>list 和 tuple</li>
</ol>
<h2 id="第一、基础类型、变量和字符编码"><a href="#第一、基础类型、变量和字符编码" class="headerlink" title="第一、基础类型、变量和字符编码"></a>第一、基础类型、变量和字符编码</h2><blockquote>
<p>计算机能处理的数据类型有很多，包括文本、图形、音频、视频等等的。上层语言对其不同的数据，定义了各自不同的数据类型。如Java的int、String、boolean，JS的Var等等的。Python也不例外：</p>
</blockquote>
<h3 id="1-1-基础类型"><a href="#1-1-基础类型" class="headerlink" title="1.1 基础类型"></a>1.1 基础类型</h3><ol>
<li><p>整数</p>
<p>  Python可以处理任意大小的整数，包括负整数。1、100、-9191等等。</p>
</li>
<li><p>浮点数</p>
<p>   浮点数也就是小数。之所以称之为浮点数。是因为其小数点是可变的，比如：1.23x10^5 和12.3x10^4是一样的。也就是类似的科学计数法 1.23e5和12.3e4。因此浮点数在计算机存储的时候可能就会有四舍五入的情况</p>
</li>
<li><p>字符串</p>
<p>   ‘ 或者 “括起来的任意文本</p>
</li>
<li><p>布尔值</p>
<p> True和False, 同时可以使用and or not来运算</p>
</li>
<li><p>空值 Python中使用<code>None</code>来表示空值，其不是<code>0</code>的意义</p>
</li>
</ol>
<h3 id="1-2-变量"><a href="#1-2-变量" class="headerlink" title="1.2 变量"></a>1.2 变量</h3><blockquote>
<p>变量在程序中就是用一个变量名标书，且区分大小写，可用<code>数字</code>和<code>_</code>表示，并不能以数组开始</p>
</blockquote>
<h4 id="a-‘aaa’"><a href="#a-‘aaa’" class="headerlink" title="a = ‘aaa’"></a>a = ‘aaa’</h4><ul>
<li>Python解释器会在内存中创建<code>aaa</code>的字符串</li>
<li>并在内存中创建一个名为<code>a</code>的变量，并将其指向<code>aaa</code></li>
</ul>
<h3 id="1-3-字符编码"><a href="#1-3-字符编码" class="headerlink" title="1.3 字符编码"></a>1.3 字符编码</h3><blockquote>
<p>最原始的由歪果仁定义的<code>ASCII</code>编码，使用127个字符，从A(65)到z(122). 其次就是各国的编码，如我们所知的<code>GB2312</code>将中文编进去。还有其他国家的类似，日本的<code>Shift_JIS</code>等等。如此一来，你会发现各国都有自己的编码，那么岂不是各种乱码。<br>因此<code>Unicode</code>就因此诞生了。<code>Unicode</code>将所有编码统一到了一套编码中，这样就解决了乱码的问题。</p>
</blockquote>
<p>Unicode和ASCII编码的区别：Unicdeo使用两个字节、ASCII使用一个字节</p>
<ul>
<li>举个栗子</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>ASCII</th>
<th>Unicode</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>十进制（65）,二进制(01000001)</td>
<td>0A (00000000 01000001)</td>
</tr>
</tbody>
</table>
<p> 因此你会发现如果你的文本全是英文的，如果使用Unicode编码的话，那么需要多一倍的存储空间，导致存储和传输上十分低效率。</p>
<p><code>UTF_8</code>应景而生，是一种<code>可变长编码</code>.<code>UTF_8</code>编码把一个Unicode字符根据不同的数组大小编码成1-6个字节，常用的英文被编码成1个字节，汉字使用3个字节。如果要传输的文本包含大量的英文字符，用UTF-8编码能节省很多空间：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>ASCII</th>
<th>Unicode</th>
<th>UTF-8</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>十进制（65）,二进制(01000001)</td>
<td>0A (00000000 01000001)</td>
<td>01000001</td>
</tr>
<tr>
<td>中</td>
<td></td>
<td>01001110 00101101</td>
<td>11100100 10111000 10101101</td>
</tr>
</tbody>
</table>
<p>所以在计算机的内存中，统一使用Unicode编码，但是需要保存到硬盘或者传输的时候，就会使用到UTF-8编码。因此在计算机上打开某个文本的时候，会首先以Unicode将其独到内存中，当修改保存的时候，又会使用UTF-8。</p>
<p>使用Unicode表示的<code>str</code>可以通过encode()转换为指定的<code>bytes</code>,例如：</p>
<ul>
<li><blockquote>
<blockquote>
<blockquote>
<p>‘A’.encode(‘ascii’)</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>b’A’</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>b’\xe4\xb8\xad\xe6\x96\x87’.decode(‘utf-8’)</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>‘中文’</li>
</ul>
<p><code>len()</code>可计算<code>str</code>包含多少个字符,len(‘abc’) = 3</p>
<p>在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。</p>
<p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div></pre></td></tr></table></figure>
<h2 id="第二、List和tuple"><a href="#第二、List和tuple" class="headerlink" title="第二、List和tuple"></a>第二、List和tuple</h2><blockquote>
<p>集合在每个语言中都有，当然Python也不例外</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python新手引导第二篇]]></title>
      <url>https://xiyoumc.github.com/2017/03/06/Python%E6%96%B0%E6%89%8B%E5%BC%95%E5%AF%BC%E7%AC%AC%E4%B8%89%E7%AF%87/</url>
      <content type="html"><![CDATA[<h1 id="Python新手引导-第三篇-Python基础"><a href="#Python新手引导-第三篇-Python基础" class="headerlink" title="Python新手引导 第三篇 Python基础"></a>Python新手引导 第三篇 Python基础</h1><blockquote>
<p>###阅读本文需要4.66分钟</p>
</blockquote>
<a id="more"></a>
<p>有其他计算机语言基础的同学，阅读本篇基础部分建议1到2分钟。</p>
<ol>
<li>基础类型和变量</li>
<li>list 和 tuple</li>
</ol>
<h2 id="第一、基础类型和变量"><a href="#第一、基础类型和变量" class="headerlink" title="第一、基础类型和变量"></a>第一、基础类型和变量</h2><blockquote>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[程序员都应该会的抓包工具--Charles]]></title>
      <url>https://xiyoumc.github.com/2017/03/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BC%9A%E7%9A%84%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7-Charles/</url>
      <content type="html"><![CDATA[<h1 id="程序员都应该会的抓包工具-Charles"><a href="#程序员都应该会的抓包工具-Charles" class="headerlink" title="程序员都应该会的抓包工具-Charles"></a>程序员都应该会的抓包工具-Charles</h1><blockquote>
<h3 id="阅读本文需要7-66分钟"><a href="#阅读本文需要7-66分钟" class="headerlink" title="阅读本文需要7.66分钟"></a>阅读本文需要7.66分钟</h3></blockquote>
<a id="more"></a>
<h5 id="抓包-其实很多程序员都不陌生了，但是真正抓过包、分析过的又有几个。"><a href="#抓包-其实很多程序员都不陌生了，但是真正抓过包、分析过的又有几个。" class="headerlink" title="抓包 其实很多程序员都不陌生了，但是真正抓过包、分析过的又有几个。"></a><code>抓包</code> 其实很多程序员都不陌生了，但是真正抓过包、分析过的又有几个。</h5><h5 id="本文将介绍几款简单易用的抓包工具，并针对目前互联网主流的Http和Https网络包进行抓取并分析，同时分享手机抓包的技术"><a href="#本文将介绍几款简单易用的抓包工具，并针对目前互联网主流的Http和Https网络包进行抓取并分析，同时分享手机抓包的技术" class="headerlink" title="本文将介绍几款简单易用的抓包工具，并针对目前互联网主流的Http和Https网络包进行抓取并分析，同时分享手机抓包的技术"></a>本文将介绍几款简单易用的抓包工具，并针对目前互联网主流的Http和Https网络包进行抓取并分析，同时分享手机抓包的技术</h5><h5 id="1-Charles、Fiddler和Wireshark"><a href="#1-Charles、Fiddler和Wireshark" class="headerlink" title="1. Charles、Fiddler和Wireshark"></a>1. Charles、Fiddler和Wireshark</h5><h5 id="2-Http、Https及其原理"><a href="#2-Http、Https及其原理" class="headerlink" title="2. Http、Https及其原理"></a>2. Http、Https及其原理</h5><h5 id="3-手机抓包"><a href="#3-手机抓包" class="headerlink" title="3. 手机抓包"></a>3. 手机抓包</h5><h5 id="4-Charles的附加功能"><a href="#4-Charles的附加功能" class="headerlink" title="4. Charles的附加功能"></a>4. Charles的附加功能</h5><h2 id="一、抓包工具"><a href="#一、抓包工具" class="headerlink" title="一、抓包工具"></a>一、抓包工具</h2><ul>
<li><code>Fiddler</code><ul>
<li>是之前我用Window电脑的时候，特别喜欢用的工具，而且当时的Fiddler足以满足的我简单的抓包工作，现在也应该更新到Fiddler3了，如果用Windows的朋友可以用Fiddler3进行抓包。</li>
</ul>
</li>
<li><code>Charles</code><ul>
<li>自从换了Mac之后我就喜欢上了这个工具，不过Charles在Windows上同样也有。</li>
</ul>
</li>
<li><code>Wireshark</code><ul>
<li>这个我不是怎么经常用，这个抓包工具可以详细的看到网络请求的三次握手，并且可支持spdy、tcp等等的网络协议抓包，当然其他两个是不支持的。</li>
</ul>
</li>
</ul>
<p>我将以Charles为例分别抓取Http和Https包：</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><h5 id="Mac破解版下载地址：http-download-csdn-net-detail-m694449212-9770583"><a href="#Mac破解版下载地址：http-download-csdn-net-detail-m694449212-9770583" class="headerlink" title="Mac破解版下载地址：http://download.csdn.net/detail/m694449212/9770583"></a>Mac破解版下载地址：<a href="http://download.csdn.net/detail/m694449212/9770583" target="_blank" rel="external">http://download.csdn.net/detail/m694449212/9770583</a></h5><h5 id="Win破解版下载地址：http-download-csdn-net-detail-m694449212-9770589"><a href="#Win破解版下载地址：http-download-csdn-net-detail-m694449212-9770589" class="headerlink" title="Win破解版下载地址：http://download.csdn.net/detail/m694449212/9770589"></a>Win破解版下载地址：<a href="http://download.csdn.net/detail/m694449212/9770589" target="_blank" rel="external">http://download.csdn.net/detail/m694449212/9770589</a></h5><h5 id="官网链接，需要购买LisenseKey：https-www-charlesproxy-com"><a href="#官网链接，需要购买LisenseKey：https-www-charlesproxy-com" class="headerlink" title="官网链接，需要购买LisenseKey：https://www.charlesproxy.com/"></a>官网链接，需要购买LisenseKey：<a href="https://www.charlesproxy.com/" target="_blank" rel="external">https://www.charlesproxy.com/</a></h5><p><img src="http://115.28.132.58:8080/docs/WX20170304-233530@2x.png" alt=""></p>
<h5 id="打开界面如下："><a href="#打开界面如下：" class="headerlink" title="打开界面如下："></a>打开界面如下：</h5><p><img src="http://115.28.132.58:8080/docs/CharlesOpen.png" alt=""></p>
<h2 id="第二、Http、Https包"><a href="#第二、Http、Https包" class="headerlink" title="第二、Http、Https包"></a>第二、Http、Https包</h2><h3 id="2-1、Http包"><a href="#2-1、Http包" class="headerlink" title="2.1、Http包"></a>2.1、Http包</h3><h5 id="2-1-1-清理Charles列表，让抓包更加清晰"><a href="#2-1-1-清理Charles列表，让抓包更加清晰" class="headerlink" title="2.1.1 清理Charles列表，让抓包更加清晰"></a>2.1.1 清理Charles列表，让抓包更加清晰</h5><p><img src="http://115.28.132.58:8080/docs/CharlesClean.png" alt=""></p>
<h5 id="2-1-2-以我的CSDN为例（m694449212）-通过Chrome点击‘我的博客’，抓到需要的包"><a href="#2-1-2-以我的CSDN为例（m694449212）-通过Chrome点击‘我的博客’，抓到需要的包" class="headerlink" title="2.1.2 以我的CSDN为例（m694449212）,通过Chrome点击‘我的博客’，抓到需要的包"></a>2.1.2 以我的CSDN为例（m694449212）,通过Chrome点击‘我的博客’，抓到需要的包</h5><p><img src="http://115.28.132.58:8080/docs/CSDNBlog.png" alt=""></p>
<h5 id="从中我们过滤出m694449212的博客包，但是这个过滤的过程需要我们去一个个找（当然如果你的经验比较足或者英语比较好的话，可以发现其实就是blog-csdn-net的包）"><a href="#从中我们过滤出m694449212的博客包，但是这个过滤的过程需要我们去一个个找（当然如果你的经验比较足或者英语比较好的话，可以发现其实就是blog-csdn-net的包）" class="headerlink" title="从中我们过滤出m694449212的博客包，但是这个过滤的过程需要我们去一个个找（当然如果你的经验比较足或者英语比较好的话，可以发现其实就是blog.csdn.net的包）"></a>从中我们过滤出m694449212的博客包，但是这个过滤的过程需要我们去一个个找（当然如果你的经验比较足或者英语比较好的话，可以发现其实就是blog.csdn.net的包）</h5><h5 id="2-1-3-分析包"><a href="#2-1-3-分析包" class="headerlink" title="2.1.3 分析包"></a>2.1.3 分析包</h5><p><img src="http://115.28.132.58:8080/docs/CharlesCSDAnly.png" alt=""></p>
<h5 id="2-1-4-Reuqest"><a href="#2-1-4-Reuqest" class="headerlink" title="2.1.4 Reuqest"></a>2.1.4 Reuqest</h5><p><img src="http://115.28.132.58:8080/docs/CharlesRequest.png" alt=""></p>
<h5 id="其中比较重要的是Cookie-网站为了辨别用户身份、进行-session-跟踪而储存在用户本地终端上的数据（通常经过加密）"><a href="#其中比较重要的是Cookie-网站为了辨别用户身份、进行-session-跟踪而储存在用户本地终端上的数据（通常经过加密）" class="headerlink" title="其中比较重要的是Cookie,网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）."></a>其中比较重要的是<code>Cookie</code>,网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）.</h5><h5 id="同时Cookie在我们爬虫的时候也是一个必不可少的东西，那么如何自动化获取Cookie呢？后面会讲解到。"><a href="#同时Cookie在我们爬虫的时候也是一个必不可少的东西，那么如何自动化获取Cookie呢？后面会讲解到。" class="headerlink" title="同时Cookie在我们爬虫的时候也是一个必不可少的东西，那么如何自动化获取Cookie呢？后面会讲解到。"></a>同时Cookie在我们爬虫的时候也是一个必不可少的东西，那么如何自动化获取Cookie呢？后面会讲解到。</h5><h5 id="2-1-5-Response"><a href="#2-1-5-Response" class="headerlink" title="2.1.5 Response"></a>2.1.5 Response</h5><p><img src="http://115.28.132.58:8080/docs/CharlesResponse.png" alt=""></p>
<h5 id="获取Cookie-通过我以往的经验"><a href="#获取Cookie-通过我以往的经验" class="headerlink" title="获取Cookie,通过我以往的经验:"></a>获取Cookie,通过我以往的经验:</h5><h5 id="a-获取Cookie的时候首先需要保证我们的浏览器环境是干净的，我说的干净其实就是清楚当前浏览器保存的Cookie，并重启浏览器。"><a href="#a-获取Cookie的时候首先需要保证我们的浏览器环境是干净的，我说的干净其实就是清楚当前浏览器保存的Cookie，并重启浏览器。" class="headerlink" title="a. 获取Cookie的时候首先需要保证我们的浏览器环境是干净的，我说的干净其实就是清楚当前浏览器保存的Cookie，并重启浏览器。"></a>a. 获取Cookie的时候首先需要保证我们的浏览器环境是干净的，我说的干净其实就是<code>清楚当前浏览器保存的Cookie</code>，并重启浏览器。</h5><h5 id="b-重启之后我们访问www-csdn-net，当前Host的Request中就不包含Cookie，那么Cookie在哪呢，其实细心点的会发现Cookie在Response的Headers-gt-set-cookie中，并在下次请求中使用到。"><a href="#b-重启之后我们访问www-csdn-net，当前Host的Request中就不包含Cookie，那么Cookie在哪呢，其实细心点的会发现Cookie在Response的Headers-gt-set-cookie中，并在下次请求中使用到。" class="headerlink" title="b. 重启之后我们访问www.csdn.net，当前Host的Request中就不包含Cookie，那么Cookie在哪呢，其实细心点的会发现Cookie在Response的Headers-&gt;set-cookie中，并在下次请求中使用到。"></a>b. 重启之后我们访问www.csdn.net，当前Host的Request中就不包含Cookie，那么Cookie在哪呢，其实细心点的会发现Cookie在<code>Response的Headers-&gt;set-cookie</code>中，并在下次请求中使用到。</h5><h5 id="c-那么当我们登录操作并携带Cookie在请求Headers中，那么登录成功之后该Cookie就会生效。之后我们的所有请求携带该Cookie就会是一个正常的请求，并能拿到需要的结果。"><a href="#c-那么当我们登录操作并携带Cookie在请求Headers中，那么登录成功之后该Cookie就会生效。之后我们的所有请求携带该Cookie就会是一个正常的请求，并能拿到需要的结果。" class="headerlink" title="c. 那么当我们登录操作并携带Cookie在请求Headers中，那么登录成功之后该Cookie就会生效。之后我们的所有请求携带该Cookie就会是一个正常的请求，并能拿到需要的结果。"></a>c. 那么当我们登录操作并携带Cookie在请求Headers中，那么登录成功之后该Cookie就会生效。之后我们的所有请求携带该Cookie就会是一个正常的请求，并能拿到需要的结果。</h5><h5 id="关于某些请求携带sign参数的，后面的文章我会讲解到破解Sign函数（其实有时候不是直接的破解而是函数的Hook-有兴趣的可以提前了解下Android或者iOS的Hook，通过IDA找到sign函数-并使用cycript调用），之后的文章我会以国外的知名App-Instagram为例，Hook它的签名函数。"><a href="#关于某些请求携带sign参数的，后面的文章我会讲解到破解Sign函数（其实有时候不是直接的破解而是函数的Hook-有兴趣的可以提前了解下Android或者iOS的Hook，通过IDA找到sign函数-并使用cycript调用），之后的文章我会以国外的知名App-Instagram为例，Hook它的签名函数。" class="headerlink" title="关于某些请求携带sign参数的，后面的文章我会讲解到破解Sign函数（其实有时候不是直接的破解而是函数的Hook,有兴趣的可以提前了解下Android或者iOS的Hook，通过IDA找到sign函数,并使用cycript调用），之后的文章我会以国外的知名App Instagram为例，Hook它的签名函数。"></a>关于某些请求携带sign参数的，后面的文章我会讲解到破解Sign函数（其实有时候不是直接的破解而是函数的Hook,有兴趣的可以提前了解下Android或者iOS的Hook，通过IDA找到sign函数,并使用cycript调用），之后的文章我会以国外的知名App Instagram为例，Hook它的签名函数。</h5><p><img src="http://115.28.132.58:8080/docs/InsMeinv.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">来个美女提提神（图片来自Instagram的Https包数据），继续往下看</div></pre></td></tr></table></figure></p>
<h3 id="2-2、Https包"><a href="#2-2、Https包" class="headerlink" title="2.2、Https包"></a>2.2、Https包</h3><h4 id="2-2-1、Https简介"><a href="#2-2-1、Https简介" class="headerlink" title="2.2.1、Https简介"></a>2.2.1、Https简介</h4><h5 id="SSL相信大家都不陌生。其实Https就是在Http基础上通过SSL协议进行加密之后的网络传输。"><a href="#SSL相信大家都不陌生。其实Https就是在Http基础上通过SSL协议进行加密之后的网络传输。" class="headerlink" title="SSL相信大家都不陌生。其实Https就是在Http基础上通过SSL协议进行加密之后的网络传输。"></a>SSL相信大家都不陌生。其实Https就是在Http基础上通过SSL协议进行加密之后的网络传输。</h5><h5 id="并通过非对称和对称加密算法来对密码和数据进行加密。具体看下图："><a href="#并通过非对称和对称加密算法来对密码和数据进行加密。具体看下图：" class="headerlink" title="并通过非对称和对称加密算法来对密码和数据进行加密。具体看下图："></a>并通过非对称和对称加密算法来对密码和数据进行加密。具体看下图：</h5><p><img src="http://115.28.132.58:8080/docs/Https.png" alt=""></p>
<h5 id="1-Client明文将自己支持的一套加密规则、一个随机数-Random-C-发送给服务器"><a href="#1-Client明文将自己支持的一套加密规则、一个随机数-Random-C-发送给服务器" class="headerlink" title="1. Client明文将自己支持的一套加密规则、一个随机数(Random_C)发送给服务器."></a>1. Client明文将自己支持的一套加密规则、一个随机数(Random_C)发送给服务器.</h5><h5 id="2-Server返回自己选择的加密规则、CA证书（服务器地址、加密公钥、以及证书颁发机构）、外加一个通过加密规则和HASH算法生成的随机数-Random-S"><a href="#2-Server返回自己选择的加密规则、CA证书（服务器地址、加密公钥、以及证书颁发机构）、外加一个通过加密规则和HASH算法生成的随机数-Random-S" class="headerlink" title="2. Server返回自己选择的加密规则、CA证书（服务器地址、加密公钥、以及证书颁发机构）、外加一个通过加密规则和HASH算法生成的随机数(Random_S)"></a>2. Server返回自己选择的加密规则、CA证书（服务器地址、加密公钥、以及证书颁发机构）、外加一个通过加密规则和HASH算法生成的随机数(Random_S)</h5><h5 id="3-Client收到Server的消息之后会"><a href="#3-Client收到Server的消息之后会" class="headerlink" title="3. Client收到Server的消息之后会:"></a>3. Client收到Server的消息之后会:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a:验证证书（地址是否是正在访问的和机构是否合法）、</div><div class="line">b:自己生成一个随机的密码(Pre_master)并使用CA证书中的加密公钥进行加密(enc_pre_master)、</div><div class="line">c:计算出一个对称加密的enc_key,通过Random_C、Random_S、Pre_master、</div><div class="line">d:生成握手信息：使用约定好的Hash算法计算握手信息，并通过enc_key和约定好的加密算法对消息进行加密</div></pre></td></tr></table></figure>
<h5 id="4-Client将enc-pre-master、加密之后的握手消息发送给Server"><a href="#4-Client将enc-pre-master、加密之后的握手消息发送给Server" class="headerlink" title="4. Client将enc_pre_master、加密之后的握手消息发送给Server"></a>4. Client将enc_pre_master、加密之后的握手消息发送给Server</h5><h5 id="5-Server收到消息之后"><a href="#5-Server收到消息之后" class="headerlink" title="5. Server收到消息之后"></a>5. Server收到消息之后</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a: 收到enc_pre_master之后，会通过私钥进行解密（非对称加密算法）得到pre_master</div><div class="line">b: 通过pre_masrer、Random_C、Random_S计算得到协商密码 enc_key</div><div class="line">c: 通过enc_key解密握手信息，验证HASH是否和客户端发来的一致</div><div class="line">d: 生成握手信息同样适用enc_key和约定好的加密算法</div></pre></td></tr></table></figure>
<h5 id="6-Server发送握手信息给Client-也就是说Server验证通过了Client-并再次发送消息给Client让其验证自己"><a href="#6-Server发送握手信息给Client-也就是说Server验证通过了Client-并再次发送消息给Client让其验证自己" class="headerlink" title="6. Server发送握手信息给Client,也就是说Server验证通过了Client,并再次发送消息给Client让其验证自己"></a>6. Server发送握手信息给Client,也就是说Server验证通过了Client,并再次发送消息给Client让其验证自己</h5><h5 id="7-客户端拿到握手信息解密，握手结束。客户端解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束。"><a href="#7-客户端拿到握手信息解密，握手结束。客户端解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束。" class="headerlink" title="7. 客户端拿到握手信息解密，握手结束。客户端解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束。"></a>7. 客户端拿到握手信息解密，握手结束。客户端解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束。</h5><h5 id="8-正常加密通信，握手成功之后，所有的通信数据将由之前协商密钥enc-key及约定好的算法进行加密解密。"><a href="#8-正常加密通信，握手成功之后，所有的通信数据将由之前协商密钥enc-key及约定好的算法进行加密解密。" class="headerlink" title="8. 正常加密通信，握手成功之后，所有的通信数据将由之前协商密钥enc_key及约定好的算法进行加密解密。"></a>8. 正常加密通信，握手成功之后，所有的通信数据将由之前协商密钥enc_key及约定好的算法进行加密解密。</h5><h4 id="其中Https使用到的加密算法如下："><a href="#其中Https使用到的加密算法如下：" class="headerlink" title="其中Https使用到的加密算法如下："></a>其中Https使用到的加密算法如下：</h4><ul>
<li>非对称加密算法：RSA，DSA/DSS</li>
<li>对称加密算法：AES，RC4，3DES</li>
<li>HASH算法：MD5，SHA1，SHA256</li>
</ul>
<h3 id="2-2-2、-Charles抓取Https原理"><a href="#2-2-2、-Charles抓取Https原理" class="headerlink" title="2.2.2、 Charles抓取Https原理"></a>2.2.2、 Charles抓取Https原理</h3><h5 id="Charles本身就是一个协议代理工具，在上篇的Https原理上，客户端和服务器的所有通信都被Charles捕获到。"><a href="#Charles本身就是一个协议代理工具，在上篇的Https原理上，客户端和服务器的所有通信都被Charles捕获到。" class="headerlink" title="Charles本身就是一个协议代理工具，在上篇的Https原理上，客户端和服务器的所有通信都被Charles捕获到。"></a>Charles本身就是一个协议代理工具，在上篇的Https原理上，客户端和服务器的所有通信都被Charles捕获到。</h5><h5 id="如下图："><a href="#如下图：" class="headerlink" title="如下图："></a>如下图：</h5><p><img src="http://115.28.132.58:8080/docs/HttpsCharles.png" alt=""></p>
<p>主要步骤如下：</p>
<h5 id="1-Charles捕获Client发送给Server请求，并伪装成客户端向服务器发起握手请求"><a href="#1-Charles捕获Client发送给Server请求，并伪装成客户端向服务器发起握手请求" class="headerlink" title="1. Charles捕获Client发送给Server请求，并伪装成客户端向服务器发起握手请求"></a>1. Charles捕获Client发送给Server请求，并伪装成客户端向服务器发起握手请求</h5><h5 id="2-服务器响应，Charles获取到服务器的CA证书，并用根证书公钥进行解密，获取到服务器的CA证书公钥。然后Charles伪造自己的CA证书，伪装为服务器的CA证书发送给客户端"><a href="#2-服务器响应，Charles获取到服务器的CA证书，并用根证书公钥进行解密，获取到服务器的CA证书公钥。然后Charles伪造自己的CA证书，伪装为服务器的CA证书发送给客户端" class="headerlink" title="2. 服务器响应，Charles获取到服务器的CA证书，并用根证书公钥进行解密，获取到服务器的CA证书公钥。然后Charles伪造自己的CA证书，伪装为服务器的CA证书发送给客户端"></a>2. 服务器响应，Charles获取到服务器的CA证书，并用根证书公钥进行解密，获取到服务器的CA证书公钥。然后Charles伪造自己的CA证书，伪装为服务器的CA证书发送给客户端</h5><h5 id="3-客户端收到返回之后，和上面讲到的过程一样，证书校验、生成密码、并使用Charles伪装的证书公钥进行加密，并生成-Https通信的协商密码enc-key"><a href="#3-客户端收到返回之后，和上面讲到的过程一样，证书校验、生成密码、并使用Charles伪装的证书公钥进行加密，并生成-Https通信的协商密码enc-key" class="headerlink" title="3. 客户端收到返回之后，和上面讲到的过程一样，证书校验、生成密码、并使用Charles伪装的证书公钥进行加密，并生成 Https通信的协商密码enc_key"></a>3. 客户端收到返回之后，和上面讲到的过程一样，证书校验、生成密码、并使用Charles伪装的证书公钥进行加密，并生成 Https通信的协商密码enc_key</h5><h5 id="4-Charles捕获到Client发来的重要信息，并使用自己伪造的证书私钥将密文解密，获取到enc-key-然后Charles使用服务器之前返回的证书公钥对明文进行加密并发送给服务器"><a href="#4-Charles捕获到Client发来的重要信息，并使用自己伪造的证书私钥将密文解密，获取到enc-key-然后Charles使用服务器之前返回的证书公钥对明文进行加密并发送给服务器" class="headerlink" title="4. Charles捕获到Client发来的重要信息，并使用自己伪造的证书私钥将密文解密，获取到enc_key.然后Charles使用服务器之前返回的证书公钥对明文进行加密并发送给服务器"></a>4. Charles捕获到Client发来的重要信息，并使用自己伪造的证书私钥将密文解密，获取到enc_key.然后Charles使用服务器之前返回的证书公钥对明文进行加密并发送给服务器</h5><h5 id="5-去之前一样，服务器收到消息之后，用私钥解开并建立信任，然后发送加密的握手信息。"><a href="#5-去之前一样，服务器收到消息之后，用私钥解开并建立信任，然后发送加密的握手信息。" class="headerlink" title="5. 去之前一样，服务器收到消息之后，用私钥解开并建立信任，然后发送加密的握手信息。"></a>5. 去之前一样，服务器收到消息之后，用私钥解开并建立信任，然后发送加密的握手信息。</h5><h5 id="6-Charles截获服务器发来的握手密文，并用对称密钥解开，再用自己伪造证书的私钥加密传给客户端"><a href="#6-Charles截获服务器发来的握手密文，并用对称密钥解开，再用自己伪造证书的私钥加密传给客户端" class="headerlink" title="6. Charles截获服务器发来的握手密文，并用对称密钥解开，再用自己伪造证书的私钥加密传给客户端"></a>6. Charles截获服务器发来的握手密文，并用对称密钥解开，再用自己伪造证书的私钥加密传给客户端</h5><h5 id="7-客户端拿到加密信息后，用公钥解开，验证HASH。握手过程正式完成，客户端与服务器端就这样建立了”信任“。"><a href="#7-客户端拿到加密信息后，用公钥解开，验证HASH。握手过程正式完成，客户端与服务器端就这样建立了”信任“。" class="headerlink" title="7. 客户端拿到加密信息后，用公钥解开，验证HASH。握手过程正式完成，客户端与服务器端就这样建立了”信任“。"></a>7. 客户端拿到加密信息后，用公钥解开，验证HASH。握手过程正式完成，客户端与服务器端就这样建立了”信任“。</h5><ul>
<li>其实在整个过程中，最重要的就是enc_key,由于Charles从一开始伪造并获取了enc_key，所以在整个通信过程中Charles充当第三者，所有信息对其来讲都是透明的。</li>
<li>其次就是根证书，这是https一个信任链的开始。这也是Charles伪造的CA证书能获得双方信任的关键。</li>
</ul>
<h3 id="2-2-3、演示Charles抓取Https"><a href="#2-2-3、演示Charles抓取Https" class="headerlink" title="2.2.3、演示Charles抓取Https"></a>2.2.3、演示Charles抓取Https</h3><blockquote>
<p>原理清楚之后，其实操作就很简单了，操作的核心点就是根证书。</p>
</blockquote>
<ul>
<li>安装根证书（Charles Root Certificate）<br><img src="http://115.28.132.58:8080/docs/CharlesRootCA.png" alt=""></li>
<li>让系统信任该证书<br><img src="http://115.28.132.58:8080/docs/TrustCharlesRootCa.png" alt=""></li>
<li>接下来将需要抓的Https链接加入到CharlesSSL代理规则中，443是Https的默认端口<br><img src="http://115.28.132.58:8080/docs/SSLProxy.png" alt=""><br>当然你也可以像我最后一条一样，使用 *:443 来抓取所有https的包。</li>
<li>通过浏览器访问自己要抓的链接，这样所有的Https都可以像Http一样明文展示都我们面前。<br><img src="http://115.28.132.58:8080/docs/HttpsGoogle.png" alt=""></li>
</ul>
<h2 id="第三、手机抓包"><a href="#第三、手机抓包" class="headerlink" title="第三、手机抓包"></a>第三、手机抓包</h2><blockquote>
<p>手机抓包的原理其实也很简单，让手机和抓包工具处于同一局域网，并将手机的WifiProxy手动代理到电脑的Ip和Charles设置的抓包端口上，具体操作可在网上找到,具体见<a href="http://blog.csdn.net/richer1997/article/details/52198024" target="_blank" rel="external">http://blog.csdn.net/richer1997/article/details/52198024</a></p>
</blockquote>
<h5 id="我这边主要讲一下手机端Https包的抓取，其实和浏览器的抓取一样："><a href="#我这边主要讲一下手机端Https包的抓取，其实和浏览器的抓取一样：" class="headerlink" title="我这边主要讲一下手机端Https包的抓取，其实和浏览器的抓取一样："></a>我这边主要讲一下手机端Https包的抓取，其实和浏览器的抓取一样：</h5><ul>
<li>首先需要安装Charles的根证书到手机上。<br><img src="http://115.28.132.58:8080/docs/InstallRoomIOS.png" alt=""></li>
<li>点击之后，会弹出让你在手机上配置代理到对应Ip和端口，之后通过手机浏览器打开chls.pro/ssl<br><img src="http://115.28.132.58:8080/docs/DownloadCA.png" alt=""><h5 id="使用手机访问该链接之后，会自动被识别为证书，并跳转到：-当然我这里已经是安装过的，未安装的点击右上角安装即可"><a href="#使用手机访问该链接之后，会自动被识别为证书，并跳转到：-当然我这里已经是安装过的，未安装的点击右上角安装即可" class="headerlink" title="使用手机访问该链接之后，会自动被识别为证书，并跳转到：(当然我这里已经是安装过的，未安装的点击右上角安装即可)"></a>使用手机访问该链接之后，会自动被识别为证书，并跳转到：(当然我这里已经是安装过的，未安装的点击右上角安装即可)</h5><img src="http://115.28.132.58:8080/docs/WechatIMG3.jpeg" alt=""></li>
<li>之后就类似与PC端抓Https包原理一样，手机端的证书被作为根证书使用，并通过Charles拿到enc_key.将所有通信过程透明化。</li>
</ul>
<h2 id="第四、Charles的附加功能"><a href="#第四、Charles的附加功能" class="headerlink" title="第四、Charles的附加功能"></a>第四、Charles的附加功能</h2><blockquote>
<p>在我刚开始使用Charles的时候，我只是用来简单的抓抓接口，直到我看到别人使用BurpSuite自定义请求数据并Repeat的时候，我在考虑Charles是否也有这种功能。当然不出我所料，Charles也是支持的。</p>
</blockquote>
<h5 id="在对应接口上点击右键，出现菜单，其中我经常使用到的就是Compose、Repeat和RepeatAdvanced"><a href="#在对应接口上点击右键，出现菜单，其中我经常使用到的就是Compose、Repeat和RepeatAdvanced" class="headerlink" title="在对应接口上点击右键，出现菜单，其中我经常使用到的就是Compose、Repeat和RepeatAdvanced"></a>在对应接口上点击右键，出现菜单，其中我经常使用到的就是Compose、Repeat和RepeatAdvanced</h5><p><img src="http://115.28.132.58:8080/docs/CharlesMenu.png" alt=""></p>
<h5 id="Compose-可直接自定义对应的请求，并执行该请求。这个对我们抓包用处很大。我们可以从中得到该接口的必填参数等等的。"><a href="#Compose-可直接自定义对应的请求，并执行该请求。这个对我们抓包用处很大。我们可以从中得到该接口的必填参数等等的。" class="headerlink" title="Compose:可直接自定义对应的请求，并执行该请求。这个对我们抓包用处很大。我们可以从中得到该接口的必填参数等等的。"></a>Compose:可直接自定义对应的请求，并执行该请求。这个对我们抓包用处很大。我们可以从中得到该接口的必填参数等等的。</h5><h5 id="Repeat：很简单就是执行一次重复请求操作"><a href="#Repeat：很简单就是执行一次重复请求操作" class="headerlink" title="Repeat：很简单就是执行一次重复请求操作"></a>Repeat：很简单就是执行一次重复请求操作</h5><h5 id="Repeat-Advanved：重复请求的高级操作，可自定义重复的次数、每隔多少秒执行。这个功能对于我们的接口的压测是很有用的。"><a href="#Repeat-Advanved：重复请求的高级操作，可自定义重复的次数、每隔多少秒执行。这个功能对于我们的接口的压测是很有用的。" class="headerlink" title="Repeat Advanved：重复请求的高级操作，可自定义重复的次数、每隔多少秒执行。这个功能对于我们的接口的压测是很有用的。"></a>Repeat Advanved：重复请求的高级操作，可自定义重复的次数、每隔多少秒执行。这个功能对于我们的接口的压测是很有用的。</h5><h5 id="除了这几个我常用的功能，当然Charles还有更多更加实用的功能，如过滤、排序等等。还需要大家去自行使用，发现更多更好、并适用于自己的功能。"><a href="#除了这几个我常用的功能，当然Charles还有更多更加实用的功能，如过滤、排序等等。还需要大家去自行使用，发现更多更好、并适用于自己的功能。" class="headerlink" title="除了这几个我常用的功能，当然Charles还有更多更加实用的功能，如过滤、排序等等。还需要大家去自行使用，发现更多更好、并适用于自己的功能。"></a>除了这几个我常用的功能，当然Charles还有更多更加实用的功能，如过滤、排序等等。还需要大家去自行使用，发现更多更好、并适用于自己的功能。</h5><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote>
<p>抓包的用处其实很大，有时候可以用来调试我们的接口、有时候也可以用来做一些对工作有益的事，当然并”不建议”用来攻击别人的网络。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python新手引导第二篇]]></title>
      <url>https://xiyoumc.github.com/2017/03/03/Python%E6%96%B0%E6%89%8B%E5%BC%95%E5%AF%BC%E7%AC%AC%E4%BA%8C%E7%AF%87/</url>
      <content type="html"><![CDATA[<h1 id="Python新手引导-第二篇-你不知道的Python"><a href="#Python新手引导-第二篇-你不知道的Python" class="headerlink" title="Python新手引导 第二篇 你不知道的Python"></a>Python新手引导 第二篇 你不知道的Python</h1><blockquote>
<p>###阅读本文需要4.66分钟</p>
</blockquote>
<a id="more"></a>
<p>上一篇进行了简单的Python讲解，包括历史、多版本共存和安装。若有不明白的同学，可尽情在公众号上给我发消息。保证”第一时间”回复.</p>
<ol>
<li>Python解释器</li>
<li>编写、运行第一个Python</li>
<li>atom-runner</li>
</ol>
<h2 id="一、Python解释器"><a href="#一、Python解释器" class="headerlink" title="一、Python解释器"></a>一、Python解释器</h2><blockquote>
<p>Python代码是以.py为扩展名的文本文件。要执行代码，就需要Python解释器去执行.py文件。</p>
</blockquote>
<p>以下将介绍多种Python解释器:</p>
<h3 id="A、-CPython"><a href="#A、-CPython" class="headerlink" title="A、 CPython"></a>A、 CPython</h3><p>Python官方的解释器是：CPython.这个解释器是用C语言开发的，因此叫CPython。在终端执行 python 启动的就是CPython解释器。<br><img src="http://115.28.132.58:8080/docs/CPython.png" alt=""></p>
<h3 id="B、-IPython"><a href="#B、-IPython" class="headerlink" title="B、 IPython"></a>B、 IPython</h3><p>Ipython是基于CPython的交互式解释器。执行 Python的能力和CPtython一样。<br>可以变量自动补全、自动缩进。与CPython不一样的是： CPython使用&gt;&gt;&gt;作为提示符，而IPython使用In[序号]:<br><img src="http://115.28.132.58:8080/docs/IPython.png" alt=""></p>
<h3 id="C、-Pypy"><a href="#C、-Pypy" class="headerlink" title="C、 Pypy"></a>C、 Pypy</h3><p>Pypy是Python开发者为了更好的Hack Python创建的项目。</p>
<p>用Python实现的Python</p>
<h3 id="D、-Jython"><a href="#D、-Jython" class="headerlink" title="D、 Jython"></a>D、 Jython</h3><p>Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。<br>这个也是我之前在写一个Java项目的时候用到的解释器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;!-- https://mvnrepository.com/artifact/jython/jython --&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;jython&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;jython&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;2.5.2&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>Java项目引入Jython之后，会将本机Python环境应用到本项目中。在Java和Python相互调用中起到了重要的作用。</p>
<h2 id="二、编写、运行第一个Python程序"><a href="#二、编写、运行第一个Python程序" class="headerlink" title="二、编写、运行第一个Python程序"></a>二、编写、运行第一个Python程序</h2><blockquote>
<p>当然在终端中，可以直接通过Python来启动CPython并进行编辑并运行，但这样的缺点就是没法保存，再次执行还必须得复制进行。所以在实际的应用场景中，我们使用文本编辑器来编写Python代码。</p>
</blockquote>
<p>以下推荐两款文本剪辑器：</p>
<ul>
<li>Atom，免费、可安装多种插件来更高效的编写代码。<br><img src="http://115.28.132.58:8080/docs/Atom_HelloWorld.png" alt=""></li>
<li>NodePad++,免费、在Window上很实用的文本编辑器<br><img src="http://115.28.132.58:8080/docs/nodepad.jpeg" alt=""></li>
</ul>
<h4 id="编写并运行第一个Python程序"><a href="#编写并运行第一个Python程序" class="headerlink" title="编写并运行第一个Python程序"></a>编写并运行第一个Python程序</h4><ol>
<li>安装好编辑器之后，打开编辑，新建文件，输入:<br><img src="http://115.28.132.58:8080/docs/PythonPrint.png" alt=""></li>
<li>编辑Python文件后，将其保存为Hello.py并放到自己的开发目录如 ~/Dev 或者 C:/dev 都可以 </li>
<li>通过cd 命令定位到文件的目录,并使用python命令来运行<br><img src="http://115.28.132.58:8080/docs/RunPython.png" alt=""></li>
<li>如果当前文件夹没有Hello.py，会报错如下：<br><img src="http://115.28.132.58:8080/docs/RunPythonError.png" alt=""> </li>
</ol>
<h2 id="三、atom-runner插件"><a href="#三、atom-runner插件" class="headerlink" title="三、atom-runner插件"></a>三、atom-runner插件</h2><blockquote>
<p>每一门语言的开始，相信大家都会去找到一个适合自己的编辑器，类似SublineText等等的。当然SublineText也可以运行Python，但是我个人比较推荐Atom。</p>
</blockquote>
<p><a href="https://github.com/lsegal/atom-runner" target="_blank" rel="external">atom-runner</a>Atom中的开源插件，可用来执行Python脚本。<br>直接在Atom settings-&gt;install 中搜索atom-runner,安装即可</p>
<p><img src="http://115.28.132.58:8080/docs/atom-runner.png" alt=""></p>
<blockquote>
<p>该插件官方文档指明，可支持JavaScript、CoffeeScript、Ruby、Python、Go、Bash 和 PowerShell scripts.</p>
<h4 id="可执行命令"><a href="#可执行命令" class="headerlink" title="可执行命令"></a>可执行命令</h4><ul>
<li>Ctrl+R (Alt+R on Win/Linux)运行当前活动窗口</li>
<li>Ctrl+Shift + R (Alt+Shif+R on Win/Linux)运行在活动窗口的选择文本</li>
<li>Ctrul+Shift+C 杀掉当前正在运行的进程</li>
<li>Escap 关闭正在运行的窗口</li>
</ul>
</blockquote>
<p>运行结果如下<br><img src="http://115.28.132.58:8080/docs/HelloWorld.png" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇阅读完成之后，花上几分钟时间自行编写并运行下Python，熟悉下Python的环境。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python新手引导第一篇]]></title>
      <url>https://xiyoumc.github.com/2017/03/03/Python%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</url>
      <content type="html"><![CDATA[<h1 id="Python新手引导-第一篇"><a href="#Python新手引导-第一篇" class="headerlink" title="Python新手引导 第一篇"></a>Python新手引导 第一篇</h1><blockquote>
<p>阅读本文需要3.66分钟</p>
</blockquote>
<a id="more"></a>
<p>目前比较流行的Python版本有2.x 和3.x,不过本人将介绍兼容所有版本的神器</p>
<ol>
<li>Python简介</li>
<li>pyenv</li>
<li>mac、Linux、Windows下安装Python</li>
</ol>
<h2 id="一、Python简介"><a href="#一、Python简介" class="headerlink" title="一、Python简介"></a>一、Python简介</h2><blockquote>
<p>Python是由著名的“龟叔”Guido van Rossum在1989年，为了打发无聊的圣诞节而编写的一个编程语言</p>
</blockquote>
<p>以下数据是通过 TIOBE获取到的一组编程语言排行榜：<br> <img src="http://115.28.132.58:8080/docs/20160118203112196" alt=""></p>
<p> 总的来说，这几种Top编程语言各有千秋。C是可以用来编写操作系统、最贴近硬件的语言。而Python是用来编写应用程序的高级编程语言。</p>
<p> 然而Python最大的好处就是有很多现成的组件让你来用，就类似让你去搭建发送邮件的自动化工具，如果从底层发送邮件开始，那么我觉得你可能需要一年半载来完成这个工作。那么这时候就体现出来Python的重要性，只需要十行左右的代码你就可以轻松的发送邮件。</p>
<p> Python为我们提供了大量的基础代码库，覆盖了网络、文件、GUI、数据库、文件等等大量的内容。<br> 在<a href="https://pypi.python.org/pypi" target="_blank" rel="external">Pypi</a>你可以搜索到任何你想用到的库。</p>
<p> 当然Python也是有缺点的，如运行速度慢、代码不能加密等等的。其实总而言之这些都可以忽略，因为上层的编译语言永远都快不过C语言。</p>
<h2 id="二、Pyenv"><a href="#二、Pyenv" class="headerlink" title="二、Pyenv"></a>二、Pyenv</h2><blockquote>
<p>当前比较流行的Python版本包括了2.x 和3.x，但是有些代码需要在2.x也有一部分是在3.x因此Python环境的管理是必须要有的。</p>
<p>Pyenv是一个Python版本管理器</p>
</blockquote>
<h4 id="A-安装Pyenv"><a href="#A-安装Pyenv" class="headerlink" title="A)安装Pyenv"></a>A)安装Pyenv</h4><p>在终端执行如下命令以安装 pyenv 及其插件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash</div></pre></td></tr></table></figure></p>
<p>安装完成后，根据提示将如下语句加入到~/.bashrc中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">export PYENV_ROOT=&quot;$HOME/.pyenv&quot;</div><div class="line">export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;</div><div class="line">eval &quot;$(pyenv init -)&quot;</div><div class="line">eval &quot;$(pyenv virtualenv-init -)&quot;   # 这句可以不加</div></pre></td></tr></table></figure></p>
<h4 id="B-使用"><a href="#B-使用" class="headerlink" title="B)使用"></a>B)使用</h4><p>pyenv 总共有11条不同的命令，具体可见：<a href="https://github.com/yyuu/pyenv/blob/master/COMMANDS.md#command-reference" target="_blank" rel="external">Comment Reference</a>.下面就最重要的几条进行说明：</p>
<h2 id="1-pyenv-versions"><a href="#1-pyenv-versions" class="headerlink" title="1. pyenv versions"></a>1. pyenv versions</h2><p>查看当前pyenv可检测到的所有版本，处于激活状态的版本前以 * 标注.<br><img src="http://115.28.132.58:8080/docs/WX20170303-190604.png" alt=""></p>
<h2 id="2-pyenv-version"><a href="#2-pyenv-version" class="headerlink" title="2. pyenv version"></a>2. pyenv version</h2><p>查看当前处于激活状态的版本，括号中内容表示这个版本是由哪条路径激活的<br><img src="http://115.28.132.58:8080/docs/WX20170303-190922.png" alt=""></p>
<h2 id="3-pyenv-install"><a href="#3-pyenv-install" class="headerlink" title="3. pyenv install"></a>3. pyenv install</h2><p>使用python-build(插件)安装一个Python版本，到$PYENV_ROOT/versions路径下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pyenv install -v <span class="number">3.4</span><span class="number">.7</span></div></pre></td></tr></table></figure></p>
<h2 id="4-pyenv-uninstall"><a href="#4-pyenv-uninstall" class="headerlink" title="4. pyenv uninstall"></a>4. pyenv uninstall</h2><p>卸载一个版本</p>
<h2 id="5-pyenv-rehash"><a href="#5-pyenv-rehash" class="headerlink" title="5. pyenv rehash"></a>5. pyenv rehash</h2><p>为所有已安装的可执行文件创建shims,因此，每当你增删了Python版本或者带有可执行文件的包(如pip)以后，都必须执行一次该命令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">python install -v <span class="number">3.4</span><span class="number">.7</span></div><div class="line">python rehash</div></pre></td></tr></table></figure>
<h2 id="6-pyenv-global"><a href="#6-pyenv-global" class="headerlink" title="6. pyenv global"></a>6. pyenv global</h2><p>设置全局的Python版本，通过将版本写入~/.pyenv/version文件的方式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pyenv <span class="keyword">global</span> <span class="number">3.4</span><span class="number">.0</span></div></pre></td></tr></table></figure></p>
<h2 id="7-pyenv-local"><a href="#7-pyenv-local" class="headerlink" title="7. pyenv local"></a>7. pyenv local</h2><p>设置面向程序的本地版本。该方式优先级高于global。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pyenv local <span class="number">3.4</span><span class="number">.7</span></div></pre></td></tr></table></figure></p>
<h2 id="8-pyenv-shell"><a href="#8-pyenv-shell" class="headerlink" title="8. pyenv shell"></a>8. pyenv shell</h2><p>设置面向shell的Python版本，通过设置当前 shell的PYENV_VERSION环境变量的方式。这个方式的优先级比local、global都高。 –unset可以取消当前shell设置的版本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pyenv shell pypy<span class="number">-2.2</span><span class="number">.1</span></div><div class="line">pyenv shell --unset</div></pre></td></tr></table></figure></p>
<h2 id="三、安装Python环境"><a href="#三、安装Python环境" class="headerlink" title="三、安装Python环境"></a>三、安装Python环境</h2><p>因为Python是跨平台，因此它可以运行在Windows、mac和各种Linux/Unix系统上。不过个人建议使用Mac，若因为穷，那么可以选择Linux/Unix。因为Windows的终端用到你吐，虽然可以在Windows上安装其他的终端程序，但是还是解决不了体验。</p>
<h4 id="A-在Mac上安装Python"><a href="#A-在Mac上安装Python" class="headerlink" title="A) 在Mac上安装Python"></a>A) 在Mac上安装Python</h4><p>OSX 10.8+都自带了2.7版本的Python.要安装最新的Python可使用brew install python3来搞定</p>
<h4 id="B-在Linux上安装Python"><a href="#B-在Linux上安装Python" class="headerlink" title="B) 在Linux上安装Python"></a>B) 在Linux上安装Python</h4><p>当前熟悉Linux的自行安装Python就可以了。否则，还是换到Windows上。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>安装成功之后，打开终端，输入python就可以了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Charles破解教程，适用于所有版本]]></title>
      <url>https://xiyoumc.github.com/2017/02/08/charles_break/</url>
      <content type="html"><![CDATA[<h1 id="Charles-注册码"><a href="#Charles-注册码" class="headerlink" title="Charles 注册码"></a>Charles 注册码</h1><h3 id="1-Windows-用户"><a href="#1-Windows-用户" class="headerlink" title="1. Windows 用户"></a>1. Windows 用户</h3><p>RegName: ANONYMOUS@chinapyg.com<br>Reg_Key: 5fae99ec65736945ba<br>官方下载后可直接激活。神key.</p>
<h3 id="2-Mac-用户"><a href="#2-Mac-用户" class="headerlink" title="2. Mac 用户"></a>2. Mac 用户</h3><p>方式一如果不行，方式二绝对可以。</p>
<h4 id="1-方式一"><a href="#1-方式一" class="headerlink" title="1. 方式一"></a>1. 方式一</h4><p>账号：WaitsUn.com<br>密码：vapg-fold-dreg-inky</p>
<h4 id="2-方式二"><a href="#2-方式二" class="headerlink" title="2. 方式二"></a>2. 方式二</h4><p>先安装Charles，然后在终端中执行下面的命令即可实现破解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">charles=/Applications/Charles.app/Contents/Java/charles.jar</div><div class="line">dir=charleshack</div><div class="line">mkdir $dir</div><div class="line">cd $dir</div><div class="line">cat &gt;&gt; License.java &lt;&lt;EOF</div><div class="line">package com.xk72.charles;</div><div class="line">public final class License &#123;</div><div class="line">    public static boolean a() &#123; return true; &#125;</div><div class="line">    public static String b() &#123; return &quot;http://www.gfzj.us&quot;; &#125;</div><div class="line">    public static String a(String name, String key) &#123; return null; &#125;</div><div class="line">&#125;</div><div class="line">EOF</div><div class="line">javac -encoding UTF-8 License.java -d .&amp;&amp; jar -uvf $charles com/xk72/charles/License.class</div><div class="line">cd .. &amp;&amp; rm -rf $dir</div></pre></td></tr></table></figure>
<a id="more"></a>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Shell语言基本教程]]></title>
      <url>https://xiyoumc.github.com/2017/02/07/linux_shell/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac、Linux安装libimobiledevice]]></title>
      <url>https://xiyoumc.github.com/2017/02/06/libimobiledevice/</url>
      <content type="html"><![CDATA[<h3 id="linux连接iOS设备并且安装ipa应用"><a href="#linux连接iOS设备并且安装ipa应用" class="headerlink" title="linux连接iOS设备并且安装ipa应用"></a>linux连接iOS设备并且安装ipa应用</h3><p>Android有个adb命令，可以很方便的做一些事情，比如直接安装应用。但是因为苹果比较封闭，没有直接的命令可以使用。但是有大牛做出了这样的东西–libimobiledevice<br><img src="https://github.com/xiyouMc/xiyoumc.github.io/blob/master/images/idevice.png?raw=true" alt="zls"><br><a id="more"></a></p>
<h3 id="关于libimobiledevice的描述"><a href="#关于libimobiledevice的描述" class="headerlink" title="关于libimobiledevice的描述"></a>关于libimobiledevice的描述</h3><p>A library to communicate with services of Apple iOS devices using native protocols.</p>
<p>ibimobiledevice又称libiphone，是一个开源包，可以让Linux支持连接iPhone/iPod Touch等iOS设备。由于苹果官方并不支持Linux系统，但是Linux上的高手绝对不能忍受因为要连接iOS设备就换用操作系统这个事儿。因此就有人逆向出iOS设备与Windows/Mac Host接口的通讯协议，最终成就了横跨三大桌面平台的非官方版本USB接口library。经常用Linux系统的人一定对libimobiledevice不陌生，但是许多Windows和Mac用户也许就不知道了。事实上，它同iTools一样，都是可以替代iTunes，进行iOS设备管理的工具。因为源码是开放的，可以自行编译，所以对很多开发者而言可以说更为实用。</p>
<p>可以自行到GitHub上下载编译<a href="https://github.com/libimobiledevice/libimobiledevice" target="_blank" rel="external">https://github.com/libimobiledevice/libimobiledevice</a></p>
<p>不过这里用简单的方式分别在mac已经ubuntu上进行安装</p>
<h4 id="在mac下安装可以使用brew，brew安装方法可以自行百度"><a href="#在mac下安装可以使用brew，brew安装方法可以自行百度" class="headerlink" title="在mac下安装可以使用brew，brew安装方法可以自行百度"></a>在mac下安装可以使用brew，brew安装方法可以自行百度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> sudo brew update</div><div class="line"> sudo brew install libimobiledevice</div><div class="line">#libimobiledevice中并不包含ipa的安装命令，所以还需要安装</div><div class="line"> sudo brew install ideviceinstaller</div></pre></td></tr></table></figure>
<h4 id="ubuntu下安装需要添加一个新的软件库，里面包含了libimobiledevice"><a href="#ubuntu下安装需要添加一个新的软件库，里面包含了libimobiledevice" class="headerlink" title="ubuntu下安装需要添加一个新的软件库，里面包含了libimobiledevice"></a>ubuntu下安装需要添加一个新的软件库，里面包含了libimobiledevice</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:pmcenery/ppa</div><div class="line">sudo apt-get update</div><div class="line">apt-get install libimobiledevice-utils</div><div class="line">sudo apt-get install ideviceinstaller</div></pre></td></tr></table></figure>
<p>这里面包含了很多命令，如下<br><img src="https://github.com/xiyouMc/xiyoumc.github.io/blob/master/images/idevice.png?raw=true" alt="zls"></p>
<h3 id="如要安装一个ipa文件到手机上可以使用"><a href="#如要安装一个ipa文件到手机上可以使用" class="headerlink" title="如要安装一个ipa文件到手机上可以使用"></a>如要安装一个ipa文件到手机上可以使用</h3><p>ideviceinstaller -i 命令安装一个ipa文件到手机上，如果是企业签名的，非越狱机器也可以直接安装了</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2016年度总结]]></title>
      <url>https://xiyoumc.github.com/2017/01/24/2016%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="2016年度总结"><a href="#2016年度总结" class="headerlink" title="2016年度总结"></a>2016年度总结</h1><blockquote>
<p>2016年很快，离上次写总结已经一年了。平时文档倒是写的不少，但是真正要总结起来自己，确实有点说不出口，那么就简单的总结下。从事业、生活等。</p>
</blockquote>
<a id="more"></a>
<ul>
<li><p>事业</p>
<blockquote>
<p>事业即我的技术，从刚进入职场，就开始做框架上的东西，现在想来这也是一个很不错的开始。因为少了业务的繁杂，多了技术的沉淀和技术的优化—Hybrid。<br>Hybrid是一个混合式开发的技术，通过JSBridge来桥接H5和Native。这个框架着实是影响到了我之后的发展规划。在开发这个系统的过程中，学习到了很多：</p>
</blockquote>
<ol>
<li>JS和H5当然是第一个学习到的东西，这两个技术一直是我在学生时期想要学习的但是一直没有沉下心来学习。</li>
<li>Module间的依赖关系，一年半左右的Hybrid开发，也确实是让我积累了很多关于模块依赖、接口开发等等的技术，并一步步提升自己的开发效率。</li>
<li>整个App的插件化开发，在开发Hybrid的同时我经常会去问框架同学问题，问他们关于App插件化、动态注入、懒加载等等的技术，这也是为自己后面开发插件化框架打下了基础。</li>
<li>插件化框架，去年中旬花了一段时间去研究ClassLoader，遇到了很多坑，也一一进行了填补,虽然不是一个多么牛逼的框架，但是确实是让我学习到了很多。当然现在也是开源在我的Github，<a href="https://github.com/xiyouMc/AppDynamicFramework" target="_blank" rel="external">Apk插件化开发</a></li>
<li>接触业务，去年下半年一直在开发业务中，一个从零开始的业务，这也算是将自己沉淀的技术进行一次应用的过程，业务有时候根本不是取决于你的技术，而是取决于各种因素，如果你是程序员你会懂得。</li>
<li>16年我也花了很多时间在Github上，每天必看Trending. Java、JS、Html等等的技术。16年也认识了很多业内的大神。</li>
<li>2017年将转型Growth Hacker，致力于公司的数据增长，将会放下Android的重心，当然Android还依然是我的一个长处。</li>
</ol>
</li>
</ul>
<ul>
<li><p>生活</p>
<blockquote>
<p>对我而言，技术的产出永远都是生活质量的提升。有时候我在想:”如果能让我开心、很爽的开发自己喜欢的技术，那么金钱对我来说都是多余的”<br>这个想法是多么幼稚.下半年一直在考虑房子的问题，看了周围一大圈，发现全都是16年9 10月份上涨之后的情况，当然貌似也是G20导致的。<br>据周围人的看法，17年将不会有很大的变动，所以在年后将会去进一步了解并决定。 这也是我去年搬家的时候对17年立的flag。希望会实现。<br>16年成长了很多，也学会了如何去承担一份感情。褪去了过去的幼稚，重新认识自己，看清自己，并去选择对方。一起走下去。</p>
</blockquote>
</li>
<li><p>有意思的东西</p>
<blockquote>
<p>上个周末，花了一点时间将之前自己的一个老应用接入了支付模块，这个系统一直以来都是免费提供给母校的学生使用的，但是慢慢的失去了很多开发的动力，因此<br>我决定花点时间将盈利加进去，刚更新那几天，每天100左右的收入是有的，当然我并没有多在乎一天能多钱。只是为了增加自己平时空闲时间去开发的动力。当然后面<br>还是降了下来，也让我意识到运营的重要性。之前自己一直都是扮演产品和开发的角色，后面增加支付，又得扮演运营的角色，最后还是证明的我不是做运营的料。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>2017</p>
<blockquote>
<p>2017年，也不说是新的开始了，因为有很多事情要一直做下去。</p>
<ol>
<li>这一年，我会花更多的时间在开源方面、自身技术的深度沉淀和公司的数据增长上，并继续向周围技术进行扩散。</li>
<li>买房、买车。。。。</li>
<li>那么是否考虑结婚呢。。。</li>
</ol>
</blockquote>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Tar包高优化解析]]></title>
      <url>https://xiyoumc.github.com/2017/01/21/TarParse/</url>
      <content type="html"><![CDATA[<h1 id="本文将介绍一个针对Tar包解析时的优化方案，旨在优化内存、提高效率。"><a href="#本文将介绍一个针对Tar包解析时的优化方案，旨在优化内存、提高效率。" class="headerlink" title="本文将介绍一个针对Tar包解析时的优化方案，旨在优化内存、提高效率。"></a>本文将介绍一个针对Tar包解析时的优化方案，旨在优化内存、提高效率。</h1><h3 id="一、首先讲一个tar包的文件结构。（懂得可以绕开此段）"><a href="#一、首先讲一个tar包的文件结构。（懂得可以绕开此段）" class="headerlink" title="一、首先讲一个tar包的文件结构。（懂得可以绕开此段）"></a>一、首先讲一个tar包的文件结构。（懂得可以绕开此段）</h3><pre><code>tar只是一个归档文件，并不进行压缩。
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">　　<span class="keyword">struct</span> tar_header</div><div class="line">　　&#123;</div><div class="line">　　 <span class="keyword">char</span> name[<span class="number">100</span>];</div><div class="line">　　 <span class="keyword">char</span> mode[<span class="number">8</span>];</div><div class="line">　　 <span class="keyword">char</span> uid[<span class="number">8</span>];</div><div class="line">　　 <span class="keyword">char</span> gid[<span class="number">8</span>];</div><div class="line">　　 <span class="keyword">char</span> size[<span class="number">12</span>];</div><div class="line">　　 <span class="keyword">char</span> mtime[<span class="number">12</span>];</div><div class="line">　　 <span class="keyword">char</span> chksum[<span class="number">8</span>];</div><div class="line">　　 <span class="keyword">char</span> typeflag;</div><div class="line">　　 <span class="keyword">char</span> linkname[<span class="number">100</span>];</div><div class="line">　　 <span class="keyword">char</span> magic[<span class="number">6</span>];</div><div class="line">　　 <span class="keyword">char</span> version[<span class="number">2</span>];</div><div class="line">　　 <span class="keyword">char</span> uname[<span class="number">32</span>];</div><div class="line">　　 <span class="keyword">char</span> gname[<span class="number">32</span>];</div><div class="line">　　 <span class="keyword">char</span> devmajor[<span class="number">8</span>];</div><div class="line">　　 <span class="keyword">char</span> devminor[<span class="number">8</span>];</div><div class="line">　　 <span class="keyword">char</span> prefix[<span class="number">155</span>];</div><div class="line">　　 <span class="keyword">char</span> padding[<span class="number">12</span>];</div><div class="line">　　&#125;;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>&gt;<br>　　以上是Tar中保存文件信息的数据结构，其后跟着的就是文件的内容。<br> size为文件大小的八进制字节表示，例如文件大小为90个字节，那么这里就是八进制的90，即为132。<br>　　其中，文件大小，修改时间，checksum都是存储的对应的八进制字符串，字符串最后一个字符为空格字符<br>　　checksum的计算方法为出去checksum字段其他所有的512-8共504个字节的ascii码相加的值再加上256(checksum当作八个空格，即8<em>0x20）<br>　　文件内容以512字节为一个block进行分割，最后一个block不足部分以0补齐<br>　　两个文件的tar包首先存放第一个文件的tar头结构，然后存储文件内容，接着存储第二个文件的tar头结构，然后存储文件内容<br>　　所有文件都存储完了以后，最后存放一个全零的tar结构<br>　　所有的tar文件大小应该都是512的倍数，一个空文件打包后为512</em>3字节，包括一个tar结构头，一个全零的block存储文件内容，一个全零的tar结构</p>
<ul>
<li>检测tar文件格式的方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1、检测magic字段，即在0x101处检查字符串，是否为ustar。有时某些压缩软件将这个字段设置为空。如果magic字段为空，进入第2步。</div><div class="line">2、计算校验和，按照上面的方法计算校验和，如果校验和正确的话，那么这就是一个tar文件。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：在windows下面，不支持uid、uname等，有的甚至不支持magic，这样就比较麻烦了。</p>
<h3 id="二、Java层普遍的“解压”方式"><a href="#二、Java层普遍的“解压”方式" class="headerlink" title="二、Java层普遍的“解压”方式"></a>二、Java层普遍的“解压”方式</h3><p>&gt;<br>     因为在jdk中提供了 FilterInputStream,因此我们可以通过继承该类，并构造一个TarEntry的模板，在子类中按每512个字节，将一个tar流分成包含N个512字节的TarEntry. 这样我们就可以将一个tar包通过TarInputStream和TarEntry解开到一个map集合中<entryname,data>.</entryname,data></p>
<h3 id="三、内存优化的-“解压”方式"><a href="#三、内存优化的-“解压”方式" class="headerlink" title="三、内存优化的 “解压”方式"></a>三、内存优化的 “解压”方式</h3><p>&gt;<br>     由于每一个TarEntry都是一个固定大小字节的对象，那么我们可不可以直接读取这块内存，而不是将所有都常驻内存呢？<br>     答案当然是可以的。<br>    为了内存上的优化和效率上的提升，我们可以直接读取指定EntryNam的内存块。<br>    因为一个tar包基本的组成结构就是   entryName-&gt;data。我们可以拿到每一个EntryName和其对应的内存大小、偏移量，在读取的时候直接在TarInputStream中读取相应内存块。<br>   代码如下：</p>
<ol>
<li><p>一个简单维护TarEntry偏移量和字节大小的类McTarEntry。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">McTarEntry</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">long</span> offset;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">McTarEntry</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">      offset = builder.offset;</div><div class="line">      size = builder.size;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getOffset</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> offset;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> size;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">      <span class="keyword">private</span> <span class="keyword">long</span> offset = <span class="number">0</span>;</div><div class="line">      <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">offset</span><span class="params">(<span class="keyword">long</span> offset)</span> </span>&#123;</div><div class="line">          <span class="keyword">this</span>.offset = offset;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">size</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">          <span class="keyword">this</span>.size = size;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">public</span> H5TarEntry <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">new</span> McTarEntry(<span class="keyword">this</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>解析Tar包，将每个McTarEntry保存在map</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(tarPath);</div><div class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</div><div class="line">TarInputStream tis = <span class="keyword">new</span> TarInputStream(bis);</div><div class="line">TarEntry te = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">while</span> ((te = tis.getNextEntry()) != <span class="keyword">null</span>) &#123;</div><div class="line">    String entryName = te.getName();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (te.isDirectory() || TextUtils.isEmpty(entryName)) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    McTarEntry mcTarEntry = <span class="keyword">new</span> McTarEntry.Builder().offset(tis.getCurrentOffset())</div><div class="line">            .size((<span class="keyword">int</span>) te.getSize()).build();</div><div class="line"></div><div class="line">    tarEntryMap.put(entryName, h5TarEntry);</div><div class="line"></div><div class="line">&#125;</div><div class="line">tis.close();</div></pre></td></tr></table></figure>
</li>
<li><p>读取指定entryName的数据块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] get(String appId, String entryName) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          <span class="keyword">byte</span> buffer[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</div><div class="line">          <span class="keyword">int</span> count;</div><div class="line">          ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">          <span class="keyword">if</span> (!tarEntryMap.containsKey()) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">long</span> offset = tarEntryMap.get(entryName).getOffset();</div><div class="line">          <span class="keyword">int</span> entrySize = tarEntryMap.get(entryName).getSize();</div><div class="line">          FileInputStream fis = <span class="keyword">new</span> FileInputStream(tarPath);</div><div class="line">          BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</div><div class="line">          TarInputStream tis = <span class="keyword">new</span> TarInputStream(bis);</div><div class="line">          H5Log.d(TAG, <span class="string">"entryName"</span> + entryName + <span class="string">" skip offset:"</span> + offset + <span class="string">" size"</span> + entrySize);</div><div class="line">          tis.skip(offset);</div><div class="line">          <span class="keyword">if</span> (buffer.length &gt; entrySize) &#123;</div><div class="line">              buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[entrySize];</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">int</span> bufferSize = <span class="number">0</span>;</div><div class="line">          <span class="keyword">while</span> ((count = tis.read(buffer)) != -<span class="number">1</span>) &#123;</div><div class="line">              bos.write(buffer, <span class="number">0</span>, count);</div><div class="line">              bufferSize += count;</div><div class="line">                 <span class="comment">// 当前buffer加上已经读取的bufferSize如果超过entrySize那么我们就应该重新计算buffer进行最后一次读取。</span></div><div class="line">              <span class="keyword">if</span> ((bufferSize + buffer.length) &gt; entrySize) &#123;</div><div class="line">                  buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[entrySize % bufferSize];</div><div class="line">                  bufferSize = entrySize - entrySize % bufferSize;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (buffer.length == entrySize || entrySize == bufferSize) &#123;</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          tis.close();</div><div class="line">          <span class="keyword">byte</span>[] data = bos.toByteArray();</div><div class="line">          <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">          &#125;</div><div class="line">          H5Log.d(TAG, <span class="string">"entryName:"</span> + entryName);</div><div class="line">          <span class="keyword">return</span> data;</div><div class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">          H5Log.e(TAG, <span class="string">"exception :"</span> + e);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>  这样就可以通过指定的entryName，根据其offset和 size 计算到这个entry在TarStream中固定内存块，从而拿到真正的数据。</p>
</li>
</ol>
<h3 id="总结：两种读取方式的区别："><a href="#总结：两种读取方式的区别：" class="headerlink" title="总结：两种读取方式的区别："></a>总结：两种读取方式的区别：</h3><ul>
<li>第一种<br>优点：减少了I/O操作。<br>缺点：耗费了内存。假如一个很大的资源在这个tar中，但是被使用的概率很低，这样耗费了内存从而不值得这么做。</li>
<li>第二种<br>优点：节省了内存，提高了读取效率<br>缺点：增加了I/O操作，Tar资源可能存在被篡改的风险。</li>
</ul>
<p>Thanks.<br>  By MC.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[最近心烦]]></title>
      <url>https://xiyoumc.github.com/2016/12/19/%E6%9C%80%E8%BF%91%E5%BF%83%E4%BA%8B/</url>
      <content type="html"><![CDATA[<p>不知道自己是将工作带到了生活还是生活带到了工作。。。<br><a id="more"></a></p>
<blockquote>
<p>最近事真的很多，也导致了自己事很多。 </p>
<p>喜欢的人，自己变得约束力越来越多。这不是我要的。<br>我很想放放松松的恋爱。 最近对你一直很闹脾气，动不动就闹脾气。  我想我是该冷静冷静了。<br>让我们开开心心的恋爱下去吧。  一直。相爱。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[戒烟]]></title>
      <url>https://xiyoumc.github.com/2016/10/26/%E6%88%92%E7%83%9F/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/xiyouMc/xiyoumc.github.io/blob/master/images/timg.jpeg?raw=true" alt=""><br>以后每天都会在这里记录，戒烟史！<br><a id="more"></a><br>GoGoGo</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大姨夫]]></title>
      <url>https://xiyoumc.github.com/2016/10/25/%E5%A4%A7%E5%A7%A8%E5%A4%AB/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/xiyouMc/xiyoumc.github.io/blob/master/images/big.jpg?raw=true" alt=""><br>最近又开始胡思乱想，针对感情、爱情总是一段时间就害怕会分开。特么的都是自己作死。哈哈哈<br><a id="more"></a><br>有一种大姨夫的感觉，有一种小女人的心思，有一种想狠狠抱着你的想法。<br>这是病，得治。自己胡思乱想，想的多，多听听歌吧。<br>大家都很忙，过好自己，照顾好爱的人。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Alison]]></title>
      <url>https://xiyoumc.github.com/2016/09/07/Alison/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Baby, You Complete Me.<br><a id="more"></a></p>
<ul>
<li>Hey there,sexy lady</li>
<li>I`m loving what you do</li>
<li>I`m thinking so are you</li>
<li>You`re trying to dent it</li>
<li>But I know I changed your mind</li>
<li>And please don`t try to fight it</li>
<li>Cause I know that you`ll be mine</li>
<li>Be mine.</li>
<li>I want you,baby</li>
<li>Come get it,girl</li>
<li>I need you,baby</li>
<li>I`m on you,girl</li>
</ul>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[憧憬]]></title>
      <url>https://xiyoumc.github.com/2016/09/07/Home/</url>
      <content type="html"><![CDATA[<blockquote>
<p>时常在憧憬未来 、未来 家的样子</p>
</blockquote>
<p><img src="https://github.com/xiyouMc/xiyoumc.github.io/blob/master/images/home.jpg?raw=true" alt="zls"></p>
<a id="more"></a>
<blockquote>
<ul>
<li>一直都想有个家、有自己的妻儿</li>
<li>有一个可以依靠、也可以安心的家</li>
<li>So 让我们一起努力。有一天你会是我的妻子，我会是你的丈夫，你我会是孩子的父母。</li>
</ul>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[You are My Sunshine.]]></title>
      <url>https://xiyoumc.github.com/2016/09/02/Sun/</url>
      <content type="html"><![CDATA[<p>我喜欢温暖、你恰好是太阳<br><a id="more"></a></p>
<blockquote>
<p>时间流逝<br>忙碌的项目开发，无数的接口，无数的调试<br>Github也好久没更新<br>不过。。。<br>不过。。。最开心 幸福的事是拥有了你<br>我喜欢温暖、你恰好是太阳</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[平淡]]></title>
      <url>https://xiyoumc.github.com/2016/08/18/822/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/xiyouMc/xiyoumc.github.io/blob/master/images/lover.jpg?raw=true" alt="zls"></p>
<p>少年，我爱上你了<br><a id="more"></a></p>
<p>&lt;告白气球&gt;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[爱情观]]></title>
      <url>https://xiyoumc.github.com/2016/08/18/Lover/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/xiyouMc/xiyoumc.github.io/blob/master/images/shelizi.png?raw=true" alt="zls"></p>
<p>诸心，皆为非心 心中无物、无心，便是真心<br><a id="more"></a></p>
<ul>
<li>佛教劝人学习放下万缘，不要执着感情，却不是要人无情，因为，人本来就是有情众生，只要把爱情的聚散当成因缘变化来看，明白“缘散则散，缘聚则聚”的道理，爱、恨便能在这一念之间转变、释怀。只要是人，就不可能没有感情，佛教称众生为“有情”，就是因为“有爱”的缘故。人活在世界上，除了饮食的养分，还需要精神的滋润，而感情就是最好的精神滋润剂，因此，感情和生命可说是息息相关的。感情虽然带给人很多温暖，却也充满痛苦；相爱的人，感情浓烈，如胶似漆分不开，一旦爱过了头，或失去了爱，就变成了苦；也有人以为只要不动情，就不会为爱所苦，这恐怕是一厢情愿的想法，既然情爱和生命息息相关，无论是否定它，或硬生生地把它切断，既不合乎佛法的因果，也不合乎人情的道理。佛教虽然劝人学习放下万缘，不要执着感情，却不是要人无情，因为，人本来就是有情众生。</li>
</ul>
<ul>
<li>遇上触礁的爱情<blockquote>
<p>然而，男女间的感情，往往非自己的期待所能控制。假如有一天，你的女朋友或是男朋友突然跟你说：“对不起！我已经遇到更适合的人，请你以后不要再来找我。”你会不会觉得晴天霹雳？觉得自己被背叛、被抛弃了？失恋的人，常常悲观地觉得生不如死：“连我最爱的人都不要我了，我还活下去做什么？” 有时候甚至还会骂说：“哼！你不要我，我本来就不想要你了。”或是“真是有眼无珠。”<br>有人为情轻生，结束自己的生命；有人为情杀人，抱着“你让我这样痛苦，我也不让你快活”；或是“我得不到你，天下人也甭想得到你”的偏激心理，而把对方杀了，甚至有的在杀了对方之后，自己也跟着自杀。大多数的人都知道，爱情是双向的，既然如此，如果对方不爱你，就不要苦苦追求不舍，应该知趣地离开，可是，有些人偏偏就是死心眼，非卿不娶，非君不嫁，不但为对方带来困扰，也让自己陷入困境。话虽这么说，毕竟人非草木，谁能无情？一般的人，仍常常为情所苦，可见得要放下感情，其实是件很不容易的事。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>以因缘观化解爱恨* </p>
<blockquote>
<p>因爱而生怨、生恨是很不幸的，从佛法的观点来看，这些都是愚痴的行为，因为真正的爱情要双方你情我愿，有因有缘才能成就，不是自己想要就要。假使对方已经明白拒绝你的感情，自己却还想尽办法，想把对方追回来；就好像赌输的人一样，心中不服气，老是想翻本，钱输光了就想办法再借，也因而愈陷愈深，不可自拔，既然知道无法挽回，就不要再陷下去了，应该赶快撤退，就算是以此为戒，至少学到经验，也就够了，这样就是对自己慈悲。慈悲不仅是照顾别人，事实上，也是在保护自己。当爱情受到挫折时，应试着化解自己心中的愤怒、不平。佛法当中“空”的观念，是最能够助人摆脱痛苦的。只要把爱情的聚散当成因缘变化来看，明白“缘散则散，缘聚则聚”的道理，爱、恨便能在这一念之间转变、释怀。</p>
</blockquote>
</li>
<li><p>陷入痛苦的爱情</p>
<blockquote>
<p>为什么爱情要俘虏人呢？很多情侣往往会说：“我爱你爱得要死！”或是喜欢说：“我是你的一半，你是我的一半！” 明明是不同的两个人，却彼此互相要求对方，成为自己的一部分，这种“爱”，都希望既要俘虏对方的人，也要俘虏对方的心；控制他的行动，还要控制他的心。所谓“俘虏”，其实就是占有，就是把自我价值扩展到他人身上。男女间的爱，本来就是一种互相的占有。你想占有他，他也想占有你，因为都想占有，所以就分不开了，这样的“爱”，到头来，却只让对方更想逃走。<br>此外，很多人谈恋爱，其实是想找个依靠，也就是找“靠山”的心态。我要靠我的男朋友、我要靠我的女朋友、我要靠我的丈夫、我要靠我的太太，刚开始，依赖一下、靠一靠，可能觉得很温馨。可是，靠久了，对方可能就会想：“怎么老是要靠我？我好累喔！” 偶尔靠一靠是甜蜜的，但老是靠着，就会成了对方的麻烦和负担。即使在爱情的两人世界中，每个人都还是独立的自我，不管是男的还是女的，每个人都怕别人变成自己的负担，如果不能够独立，只想要依靠或是指望另一半，就会成了对方的包袱。</p>
</blockquote>
</li>
<li><p>以尊重的心态经营爱情</p>
<blockquote>
<p>真正的爱情应该是无私的付出，但是多半的爱情还是以占有、控制为出发点，这和人的不安全感有关，因此，要求情人对你做到全心的奉献，恐怕是很困难的事。也因如此，甜蜜的爱情，却往往是最痛苦的。期待、要求，希望得到对方“真心”的对待和付出，可是，这种心是“真心”吗？《金刚经》中有一段话：“如来说诸心，皆为非心，是名为心。”“诸心”，是指每一个众生的种种心理活动现象，这些都是虚妄的，从佛法的观点来看，只要有心，就都不是真心，要“心无所住”，心中无物、无心，那才是“真心”。所以说，占有心、依靠心、期待心，都不叫“真心”，而是“烦恼心”。</p>
</blockquote>
</li>
<li><p>古人说“相敬如宾”，虽是老生常谈，却是能够维系长久爱情的真正智慧。如果想避免吵架、误解，或者是想消融不断的期待、要求，在遇到诸如此类的问题时，不妨以尊重的心态，心悦诚服、欢欢喜喜、平平静静去面对、解决，心中的纠结，其实在当下都能即得化解。爱情里的关系，并不是在互相执着、纠缠和占有，而是互相的贡献、成长和学习。能够互相关怀、照顾、包容，去彼此计较、相互猜疑，多沟通，并相互信赖，才能成为菩萨伴侣。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hybrid调试指南]]></title>
      <url>https://xiyoumc.github.com/2016/08/17/hybrid%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/xiyouMc/HybridApp/blob/master/%20hybrid.png?raw=true" alt="inspect1"></p>
<h1 id="Hybrid调试指南"><a href="#Hybrid调试指南" class="headerlink" title="Hybrid调试指南"></a>Hybrid调试指南</h1><blockquote>
<p>开发接口过程中如何自测接口?</p>
</blockquote>
<a id="more"></a>
<h2 id="Dependency"><a href="#Dependency" class="headerlink" title="Dependency"></a>Dependency</h2><blockquote>
<ul>
<li>Chrome</li>
<li>Android SDK Level &gt;=19</li>
</ul>
</blockquote>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><blockquote>
<ul>
<li>Android设备连接电脑，并打开USB调试</li>
<li>通过Hybrid打开任意页面</li>
<li>使用Chrome浏览器打开，<a href="chrome://inspect" target="_blank" rel="external">chrome://inspect</a>,  调用JSBridge对应的接口</li>
</ul>
</blockquote>
<h2 id="Picture"><a href="#Picture" class="headerlink" title="Picture"></a>Picture</h2><blockquote>
<ul>
<li>以下是 “隐藏TitleBar”为例，通过JSBridge来隐藏Native的标题栏</li>
</ul>
</blockquote>
<ul>
<li>打开Console控制台</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiyouMc/HybridApp/master/images/inspect1.png" alt="inspect1"></p>
<ul>
<li>注入JSBridge.call(“hideTitlebar”);</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiyouMc/HybridApp/master/images/inspect2.png" alt="inspect2"></p>
<ul>
<li>App端隐藏掉Titlebar</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiyouMc/HybridApp/master/images/hideTitlebar.png" alt="hideTitle"></p>
<ul>
<li>通过Hybrid打开任意页面，测试页面-Slideplus素材中心页</li>
<li>使用Chrome浏览器打开，<a href="chrome://inspect" target="_blank" rel="external">chrome://inspect</a></li>
</ul>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><p>&gt;</p>
<ul>
<li>JSBridge.call(“hideTitlebar”)  —Hide Title bar</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[插件化框架简介]]></title>
      <url>https://xiyoumc.github.com/2016/05/05/%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>本框架是建立在 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-load-apk</a>进行的上层封装。增加插件动态加载到libs目录和针对模块Service的注入。</p>
<p>本文将以H5Core为插件进行讲解。</p>
<h5 id="更新日志："><a href="#更新日志：" class="headerlink" title="更新日志："></a>更新日志：</h5><p>&gt;</p>
<ul>
<li>2016/7/6  commit -m “增加懒加载功能”   hash: 2a335dc49654c80fb6779cacefdf3ed712c23a8</li>
</ul>
<h1 id="插件化框架简介"><a href="#插件化框架简介" class="headerlink" title="插件化框架简介"></a>插件化框架简介</h1><ul>
<li>插件化是将Apk中功能类似的模块封装到独立的Application中，并根据框架约定好的规则完成Apk的动态加载和Service的注入。</li>
<li>本框架是将每一个Apk作为so并使用定制化打包脚本将so文件打到主Project/libs/jniLibs，这样在apk编译的时候就可以将so文件直接装载进data/data/xxxxx/lib目录，支持后续的DexClassLoader加载该文件。</li>
<li>每一个模块分为Api和Core，Api作为模块对外提供的接口，Core作为封装好的独立模块，每一个模块做好自己的混淆。注入操作需在Core中定义，下文将介绍这块。</li>
<li><p>主Client增加bundleList.config文件，文件配置：</p>
<pre><code>bundleName=h5core    //直接加载的插件
lazyBundle=h5core.H5Service&amp;H5Api //懒加载插件
</code></pre></li>
</ul>
<h2 id="一、Framework"><a href="#一、Framework" class="headerlink" title="一、Framework"></a>一、Framework</h2><ul>
<li>Framework提供了一个动态加载apk的框架，并提供一个加载独立模块的BaseMateinfo。</li>
</ul>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol>
<li>开发模块时需要在  module(core)/package name/下定义Metainfo继承自BaseMateinfo。 这样该模块在主Apk安装的时候就会动态将模块的接口注入到框架，后续提供给其它组件调用。</li>
<li><p>模块提供的主要方法类有:BasePluginActivity,BasePluginFragmentActivity,BasePluginService,BaseMateinfo,MarkApplication.</p>
<pre><code>BasePluginActivity: 基础的Activity，每一个模块中的Activity都需要继承该类，完成模块中的Activity的代理化。
BasePluginFragmentActivity： 基础的FragmentActivity，同上。需要继承该类
BasePluginService: 基础的Service，同上。
BaseMateinfo: 模块Service注入的基类，其它模块的Core层都需要定义一个Metainfo来继承该类，并完成Service的注入。（后面会介绍如何注入）
MarkApplication:模块的Application，可以拿到模块的Context，并提供查找Service，启动Activity等方法。
</code></pre></li>
</ol>
<h2 id="二、Activity层"><a href="#二、Activity层" class="headerlink" title="二、Activity层"></a>二、Activity层</h2><ul>
<li>为了让proxy全面接管apk中所有activity的执行，需要为activity定义一个基类BaseActivity，在基类中处理代理相关的事情，同时BaseActivity还对是否使用代理进行了判断，如果不使用代理，那么activity的逻辑仍然按照正常的方式执行，也就是说，这个apk既可以按照执行，也可以由宿主程序来执行。</li>
</ul>
<h3 id="独立模块架构"><a href="#独立模块架构" class="headerlink" title="独立模块架构"></a>独立模块架构</h3><ul>
<li>模块分类：Api和Core,针对不同业务可追加前缀。</li>
<li>每一个模块对外提供一个Service供其他模块引用。Service的Interface类放在Api模块，实现类放在Core。实现独立模块的封装。</li>
<li><p>Service注册：在Core的根包目录创建MetaInfo类，继承Framework模块的BaseMetaInfo.如下：</p>
<pre><code>public class MetaInfo extends BaseMetaInfo {
private static final String TAG = &quot;MetaInfo.Init&quot;;
public MetaInfo() {
    Log.d(TAG,&quot;Service init&quot;);
    ServiceDescription serviceDescription = new ServiceDescription();
    serviceDescription.setInterfaceName(XXService.class.getName());
    serviceDescription.setClassName(XXServiceImpl.class.getName());
    services.add(serviceDescription);
}
}
注解:
ServiceDescription类是针对Service的描述类，将接口和实现封装在该对象，并将其添加到services列表中。
</code></pre><p>  以上工作就完成了模块的注入。</p>
</li>
</ul>
<h3 id="模块之间依赖"><a href="#模块之间依赖" class="headerlink" title="模块之间依赖"></a>模块之间依赖</h3><ul>
<li>模块只要是通过Api包的依赖进行访问。由于Api是作为一个Jar存在的，因此可以直接被其它模块依赖，并切记使用 provided来依赖，防止Api的jar包被编译进模块。</li>
<li><p>模块之间访问：主要的类有MarkApplication、MicroApplicationContext。</p>
<pre><code>比如其他模块访问Core:
XXService xxservice = MarkApplication.getInstance().getMicroApplicationContext().findServiceByInterface(XXService.class.getName());
这样就可以拿到容器的Service，从而调用其提供的方法。
</code></pre></li>
</ul>
<h3 id="模块内部资源的访问"><a href="#模块内部资源的访问" class="headerlink" title="模块内部资源的访问"></a>模块内部资源的访问</h3><ul>
<li><p>由于每一个模块作为独立的apk打入主apk,因此访问该apk的上下文不再是该apk的，而是框架层的代理上下文。</p>
<pre><code>示例：
1、Resourse获取
    MarkApplication.getInstance().getMicroApplicationContext().getResourcesByBundle(&quot;xxcore&quot;);
2、Assets获取
    MarkApplication.getInstance().getMicroApplicationContext().getAssetsByBundle(&quot;xxcore&quot;);
</code></pre></li>
</ul>
<h3 id="Gradle打包命令详解"><a href="#Gradle打包命令详解" class="headerlink" title="Gradle打包命令详解"></a>Gradle打包命令详解</h3><ul>
<li>gradle build ：编译当前模块。</li>
<li>gradle buidleJar:针对本模块生成jar包，保存目录在  xxx/build/libs/xxxx.jar</li>
<li>gradle uploadArchives:上传本项目包到Nexus服务器，提供给其他模块依赖</li>
</ul>
<p>例子：</p>
<p>1、Api包的<a href="https://github.com/xiyouMc/AppDynamicFramework/blob/master/API.MD" target="_blank" rel="external">build.gradle模版</a><br>2、Core包的 <a href="https://github.com/xiyouMc/AppDynamicFramework/blob/master/CORE.MD" target="_blank" rel="external">build.gradle模版</a></p>
<h2 id="三、依赖关系介绍"><a href="#三、依赖关系介绍" class="headerlink" title="三、依赖关系介绍"></a>三、依赖关系介绍</h2><ul>
<li>如今模块化之后，依赖关系的复杂度也相比之前复杂了不少，因此梳理好依赖关系是必须考虑的问题。</li>
</ul>
<h3 id="模块化主要的依赖关系："><a href="#模块化主要的依赖关系：" class="headerlink" title="模块化主要的依赖关系："></a>模块化主要的依赖关系：</h3><pre><code>框架主要有Portal、Framework、Module三个模块：
1、Portal是项目的Launcher目录。
2、Framework是框架的架构模块。
3、Module是每一个模块，并分为Api和Core，并且Api作为Android.library、Core作为Android.application.
4、每一个模块通过依赖其它模块的Api进行组件的调用。并且每一个Core都需要依赖Framework。
</code></pre><h3 id="插件apk的开发规范"><a href="#插件apk的开发规范" class="headerlink" title="插件apk的开发规范"></a>插件apk的开发规范</h3><p>开发插件apk所需要遵循的规范：</p>
<p><del>1. 不能用this：因为this指向的是当前对象，即apk中的activity，但是由于activity已经不是常规意义上的activity，所以this是没有意义的</del></p>
<p><del>2. 使用that：既然this不能用，那就用that，that是apk中activity的基类BaseActivity中的一个成员，它在apk安装运行的时候指向this，而在未安装的时候指向宿主程序中的代理activity，anyway，that is better than this.</del></p>
<p><del>3. 不能直接调用activity的成员方法：而必须通过that去调用，由于that的动态分配特性，通过that去调用activity的成员方法，在apk安装以后仍然可以正常运行。</del></p>
<ol>
<li>启动新activity的约束：启动外部activity不受限制，启动apk内部的activity有限制，首先由于apk中的activity没注册，所以不支持隐式调用，其次必须通过BaseActivity中定义的新方法startActivityByProxy和startActivityForResultByProxy，还有就是不支持LaunchMode。</li>
<li>目前暂不支持Service、BroadcastReceiver等需要注册才能使用的组件。</li>
</ol>
<h2 id="四、更新功能"><a href="#四、更新功能" class="headerlink" title="四、更新功能"></a>四、更新功能</h2><ul>
<li><p>2016/7/6 懒加载功能</p>
<pre><code>1、bundleList.config 文件增加lazyBundle字段来标示是否进行懒加载。字段值格式：bundleName.bundleService*bundleService。这样在该插件被调用的时候，框架采取load这个dex。    
2、优化效果：681kb的so，首次启动懒加载优化100ms。
</code></pre></li>
</ul>
<p>Thankd for your reading, by Mc…    Thanks Dynamic-load-apk</p>
<p>update</p>
<h2 id="Contact-me"><a href="#Contact-me" class="headerlink" title="Contact me"></a>Contact me</h2><p>Any further question?</p>
<p><a href="mailto:tmac694449212@gmail.com" target="_blank" rel="external">Email</a> me please!</p>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><pre><code>Copyright 2016 xiyouMc

Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
</code></pre>]]></content>
    </entry>
    
  
  
</search>
