<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[2016年度总结]]></title>
      <url>https://xiyoumc.github.com/2017/01/24/2016%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="2016年度总结"><a href="#2016年度总结" class="headerlink" title="2016年度总结"></a>2016年度总结</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2016年很快，离上次写总结已经一年了。平时文档倒是写的不少，但是真正要总结起来自己，确实有点说不出口，那么就简单的总结下。从事业、生活等。</div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li><p>事业</p>
<blockquote>
<p>事业即我的技术，从刚进入职场，就开始做框架上的东西，现在想来这也是一个很不错的开始。因为少了业务的繁杂，多了技术的沉淀和技术的优化—Hybrid。<br>Hybrid是一个混合式开发的技术，通过JSBridge来桥接H5和Native。这个框架着实是影响到了我之后的发展规划。在开发这个系统的过程中，学习到了很多：</p>
<ol>
<li>JS和H5当然是第一个学习到的东西，这两个技术一直是我在学生时期想要学习的但是一直没有沉下心来学习。</li>
<li>Module间的依赖关系，一年半左右的Hybrid开发，也确实是让我积累了很多关于模块依赖、接口开发等等的技术，并一步步提升自己的开发效率。</li>
<li>整个App的插件化开发，在开发Hybrid的同时我经常会去问框架同学问题，问他们关于App插件化、动态注入、懒加载等等的技术，这也是为自己后面开发插件化框架打下了基础。</li>
<li>插件化框架，去年中旬花了一段时间去研究ClassLoader，遇到了很多坑，也一一进行了填补,虽然不是一个多么牛逼的框架，但是确实是让我学习到了很多。当然现在也是开源在我的Github，<a href="https://github.com/xiyouMc/AppDynamicFramework" target="_blank" rel="external">Apk插件化开发</a></li>
<li>接触业务，去年下半年一直在开发业务中，一个从零开始的业务，这也算是将自己沉淀的技术进行一次应用的过程，业务有时候根本不是取决于你的技术，而是取决于各种因素，如果你是程序员你会懂得。</li>
<li>16年我也花了很多一部分时间在Github上，每天必看Trending. Java、JS、Html等等的技术。16年也认识了很多业内的大神。</li>
<li>2017年将转型Growth Hacker，致力于公司的数据增长，将会放下Android的重心，当然Android还依然是我的一个长处。</li>
</ol>
</blockquote>
</li>
</ul>
<ul>
<li><p>生活</p>
<blockquote>
<p>对我而言，技术的产出永远都是生活质量的提升。有时候我在想:”如果能让我开心、很爽的开发自己喜欢的技术，那么金钱对我来说都是多余的”<br>这个想法是多么幼稚.下半年一直在考虑房子的问题，看了周围一大圈，发现全都是16年9 10月份上涨之后的情况，当然貌似也是G20导致的。<br>据周围人的看法，17年将不会有很大的变动，所以在年后将会去进一步了解并决定。 这也是我去年搬家的时候对17年立的flag。希望会实现。<br>16年成长了很多，也学会了如何去承担一份感情。褪去了过去的幼稚，重新认识自己，看清自己，并去选择对方。一起走下去。</p>
</blockquote>
</li>
<li><p>有意思的东西</p>
<blockquote>
<p>上个周末，花了一点时间将之前自己的一个老应用接入了支付模块，这个系统一直以来都是免费提供给母校的学生使用的，但是慢慢的失去了很多开发的动力，因此<br>我决定花点时间将盈利加进去，刚更新那几天，每天100左右的收入是有的，当然我并没有多在乎一天能多钱。只是为了增加自己平时空闲时间去开发的动力。当然后面<br>还是降了下来，也让我意识到运营的重要性。之前自己一直都是扮演产品和开发的角色，后面增加支付，又得扮演运营的角色，最后还是证明的我不是做运营的料。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>2017</p>
<blockquote>
<p>2017年，也不说是新的开始了，因为有很多事情要一直做下去。</p>
<ol>
<li>这一年，我会花更多的时间在开源方面、自身技术的深度沉淀和公司的数据增长上，并继续向周围技术进行扩散。</li>
<li>买房、买车。。。。</li>
<li>那么是否考虑结婚呢。。。</li>
</ol>
</blockquote>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Tar包高优化解析]]></title>
      <url>https://xiyoumc.github.com/2017/01/21/TarParse/</url>
      <content type="html"><![CDATA[<h1 id="本文将介绍一个针对Tar包解析时的优化方案，旨在优化内存、提高效率。"><a href="#本文将介绍一个针对Tar包解析时的优化方案，旨在优化内存、提高效率。" class="headerlink" title="本文将介绍一个针对Tar包解析时的优化方案，旨在优化内存、提高效率。"></a>本文将介绍一个针对Tar包解析时的优化方案，旨在优化内存、提高效率。</h1><h3 id="一、首先讲一个tar包的文件结构。（懂得可以绕开此段）"><a href="#一、首先讲一个tar包的文件结构。（懂得可以绕开此段）" class="headerlink" title="一、首先讲一个tar包的文件结构。（懂得可以绕开此段）"></a>一、首先讲一个tar包的文件结构。（懂得可以绕开此段）</h3><pre><code>tar只是一个归档文件，并不进行压缩。
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">　　<span class="keyword">struct</span> tar_header</div><div class="line">　　&#123;</div><div class="line">　　 <span class="keyword">char</span> name[<span class="number">100</span>];</div><div class="line">　　 <span class="keyword">char</span> mode[<span class="number">8</span>];</div><div class="line">　　 <span class="keyword">char</span> uid[<span class="number">8</span>];</div><div class="line">　　 <span class="keyword">char</span> gid[<span class="number">8</span>];</div><div class="line">　　 <span class="keyword">char</span> size[<span class="number">12</span>];</div><div class="line">　　 <span class="keyword">char</span> mtime[<span class="number">12</span>];</div><div class="line">　　 <span class="keyword">char</span> chksum[<span class="number">8</span>];</div><div class="line">　　 <span class="keyword">char</span> typeflag;</div><div class="line">　　 <span class="keyword">char</span> linkname[<span class="number">100</span>];</div><div class="line">　　 <span class="keyword">char</span> magic[<span class="number">6</span>];</div><div class="line">　　 <span class="keyword">char</span> version[<span class="number">2</span>];</div><div class="line">　　 <span class="keyword">char</span> uname[<span class="number">32</span>];</div><div class="line">　　 <span class="keyword">char</span> gname[<span class="number">32</span>];</div><div class="line">　　 <span class="keyword">char</span> devmajor[<span class="number">8</span>];</div><div class="line">　　 <span class="keyword">char</span> devminor[<span class="number">8</span>];</div><div class="line">　　 <span class="keyword">char</span> prefix[<span class="number">155</span>];</div><div class="line">　　 <span class="keyword">char</span> padding[<span class="number">12</span>];</div><div class="line">　　&#125;;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>&gt;<br>　　以上是Tar中保存文件信息的数据结构，其后跟着的就是文件的内容。<br> size为文件大小的八进制字节表示，例如文件大小为90个字节，那么这里就是八进制的90，即为132。<br>　　其中，文件大小，修改时间，checksum都是存储的对应的八进制字符串，字符串最后一个字符为空格字符<br>　　checksum的计算方法为出去checksum字段其他所有的512-8共504个字节的ascii码相加的值再加上256(checksum当作八个空格，即8<em>0x20）<br>　　文件内容以512字节为一个block进行分割，最后一个block不足部分以0补齐<br>　　两个文件的tar包首先存放第一个文件的tar头结构，然后存储文件内容，接着存储第二个文件的tar头结构，然后存储文件内容<br>　　所有文件都存储完了以后，最后存放一个全零的tar结构<br>　　所有的tar文件大小应该都是512的倍数，一个空文件打包后为512</em>3字节，包括一个tar结构头，一个全零的block存储文件内容，一个全零的tar结构</p>
<ul>
<li>检测tar文件格式的方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1、检测magic字段，即在0x101处检查字符串，是否为ustar。有时某些压缩软件将这个字段设置为空。如果magic字段为空，进入第2步。</div><div class="line">2、计算校验和，按照上面的方法计算校验和，如果校验和正确的话，那么这就是一个tar文件。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：在windows下面，不支持uid、uname等，有的甚至不支持magic，这样就比较麻烦了。</p>
<h3 id="二、Java层普遍的“解压”方式"><a href="#二、Java层普遍的“解压”方式" class="headerlink" title="二、Java层普遍的“解压”方式"></a>二、Java层普遍的“解压”方式</h3><p>&gt;<br>     因为在jdk中提供了 FilterInputStream,因此我们可以通过继承该类，并构造一个TarEntry的模板，在子类中按每512个字节，将一个tar流分成包含N个512字节的TarEntry. 这样我们就可以将一个tar包通过TarInputStream和TarEntry解开到一个map集合中<entryname,data>.</entryname,data></p>
<h3 id="三、内存优化的-“解压”方式"><a href="#三、内存优化的-“解压”方式" class="headerlink" title="三、内存优化的 “解压”方式"></a>三、内存优化的 “解压”方式</h3><p>&gt;<br>     由于每一个TarEntry都是一个固定大小字节的对象，那么我们可不可以直接读取这块内存，而不是将所有都常驻内存呢？<br>     答案当然是可以的。<br>    为了内存上的优化和效率上的提升，我们可以直接读取指定EntryNam的内存块。<br>    因为一个tar包基本的组成结构就是   entryName-&gt;data。我们可以拿到每一个EntryName和其对应的内存大小、偏移量，在读取的时候直接在TarInputStream中读取相应内存块。<br>   代码如下：</p>
<ol>
<li><p>一个简单维护TarEntry偏移量和字节大小的类McTarEntry。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">McTarEntry</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">long</span> offset;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">McTarEntry</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">      offset = builder.offset;</div><div class="line">      size = builder.size;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getOffset</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> offset;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> size;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">      <span class="keyword">private</span> <span class="keyword">long</span> offset = <span class="number">0</span>;</div><div class="line">      <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">offset</span><span class="params">(<span class="keyword">long</span> offset)</span> </span>&#123;</div><div class="line">          <span class="keyword">this</span>.offset = offset;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">public</span> Builder <span class="title">size</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">          <span class="keyword">this</span>.size = size;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">public</span> H5TarEntry <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">new</span> McTarEntry(<span class="keyword">this</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>解析Tar包，将每个McTarEntry保存在map</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(tarPath);</div><div class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</div><div class="line">TarInputStream tis = <span class="keyword">new</span> TarInputStream(bis);</div><div class="line">TarEntry te = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">while</span> ((te = tis.getNextEntry()) != <span class="keyword">null</span>) &#123;</div><div class="line">    String entryName = te.getName();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (te.isDirectory() || TextUtils.isEmpty(entryName)) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    McTarEntry mcTarEntry = <span class="keyword">new</span> McTarEntry.Builder().offset(tis.getCurrentOffset())</div><div class="line">            .size((<span class="keyword">int</span>) te.getSize()).build();</div><div class="line"></div><div class="line">    tarEntryMap.put(entryName, h5TarEntry);</div><div class="line"></div><div class="line">&#125;</div><div class="line">tis.close();</div></pre></td></tr></table></figure>
</li>
<li><p>读取指定entryName的数据块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] get(String appId, String entryName) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          <span class="keyword">byte</span> buffer[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</div><div class="line">          <span class="keyword">int</span> count;</div><div class="line">          ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">          <span class="keyword">if</span> (!tarEntryMap.containsKey()) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">long</span> offset = tarEntryMap.get(entryName).getOffset();</div><div class="line">          <span class="keyword">int</span> entrySize = tarEntryMap.get(entryName).getSize();</div><div class="line">          FileInputStream fis = <span class="keyword">new</span> FileInputStream(tarPath);</div><div class="line">          BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</div><div class="line">          TarInputStream tis = <span class="keyword">new</span> TarInputStream(bis);</div><div class="line">          H5Log.d(TAG, <span class="string">"entryName"</span> + entryName + <span class="string">" skip offset:"</span> + offset + <span class="string">" size"</span> + entrySize);</div><div class="line">          tis.skip(offset);</div><div class="line">          <span class="keyword">if</span> (buffer.length &gt; entrySize) &#123;</div><div class="line">              buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[entrySize];</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">int</span> bufferSize = <span class="number">0</span>;</div><div class="line">          <span class="keyword">while</span> ((count = tis.read(buffer)) != -<span class="number">1</span>) &#123;</div><div class="line">              bos.write(buffer, <span class="number">0</span>, count);</div><div class="line">              bufferSize += count;</div><div class="line">                 <span class="comment">// 当前buffer加上已经读取的bufferSize如果超过entrySize那么我们就应该重新计算buffer进行最后一次读取。</span></div><div class="line">              <span class="keyword">if</span> ((bufferSize + buffer.length) &gt; entrySize) &#123;</div><div class="line">                  buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[entrySize % bufferSize];</div><div class="line">                  bufferSize = entrySize - entrySize % bufferSize;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (buffer.length == entrySize || entrySize == bufferSize) &#123;</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          tis.close();</div><div class="line">          <span class="keyword">byte</span>[] data = bos.toByteArray();</div><div class="line">          <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">          &#125;</div><div class="line">          H5Log.d(TAG, <span class="string">"entryName:"</span> + entryName);</div><div class="line">          <span class="keyword">return</span> data;</div><div class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">          H5Log.e(TAG, <span class="string">"exception :"</span> + e);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>  这样就可以通过指定的entryName，根据其offset和 size 计算到这个entry在TarStream中固定内存块，从而拿到真正的数据。</p>
</li>
</ol>
<h3 id="总结：两种读取方式的区别："><a href="#总结：两种读取方式的区别：" class="headerlink" title="总结：两种读取方式的区别："></a>总结：两种读取方式的区别：</h3><ul>
<li>第一种<br>优点：减少了I/O操作。<br>缺点：耗费了内存。假如一个很大的资源在这个tar中，但是被使用的概率很低，这样耗费了内存从而不值得这么做。</li>
<li>第二种<br>优点：节省了内存，提高了读取效率<br>缺点：增加了I/O操作，Tar资源可能存在被篡改的风险。</li>
</ul>
<p>Thanks.<br>  By MC.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[最近心烦]]></title>
      <url>https://xiyoumc.github.com/2016/12/19/%E6%9C%80%E8%BF%91%E5%BF%83%E4%BA%8B/</url>
      <content type="html"><![CDATA[<p>不知道自己是将工作带到了生活还是生活带到了工作。。。<br><a id="more"></a></p>
<blockquote>
<p>最近事真的很多，也导致了自己事很多。 </p>
<p>喜欢的人，自己变得约束力越来越多。这不是我要的。<br>我很想放放松松的恋爱。 最近对你一直很闹脾气，动不动就闹脾气。  我想我是该冷静冷静了。<br>让我们开开心心的恋爱下去吧。  一直。相爱。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[戒烟]]></title>
      <url>https://xiyoumc.github.com/2016/10/26/%E6%88%92%E7%83%9F/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/xiyouMc/xiyoumc.github.io/blob/master/images/timg.jpeg?raw=true" alt=""><br>以后每天都会在这里记录，戒烟史！<br><a id="more"></a><br>GoGoGo</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大姨夫]]></title>
      <url>https://xiyoumc.github.com/2016/10/25/%E5%A4%A7%E5%A7%A8%E5%A4%AB/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/xiyouMc/xiyoumc.github.io/blob/master/images/big.jpg?raw=true" alt=""><br>最近又开始胡思乱想，针对感情、爱情总是一段时间就害怕会分开。特么的都是自己作死。哈哈哈<br><a id="more"></a><br>有一种大姨夫的感觉，有一种小女人的心思，有一种想狠狠抱着你的想法。<br>这是病，得治。自己胡思乱想，想的多，多听听歌吧。<br>大家都很忙，过好自己，照顾好爱的人。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Alison]]></title>
      <url>https://xiyoumc.github.com/2016/09/07/Alison/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Baby, You Complete Me.<br><a id="more"></a></p>
<ul>
<li>Hey there,sexy lady</li>
<li>I`m loving what you do</li>
<li>I`m thinking so are you</li>
<li>You`re trying to dent it</li>
<li>But I know I changed your mind</li>
<li>And please don`t try to fight it</li>
<li>Cause I know that you`ll be mine</li>
<li>Be mine.</li>
<li>I want you,baby</li>
<li>Come get it,girl</li>
<li>I need you,baby</li>
<li>I`m on you,girl</li>
</ul>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[憧憬]]></title>
      <url>https://xiyoumc.github.com/2016/09/07/Home/</url>
      <content type="html"><![CDATA[<blockquote>
<p>时常在憧憬未来 、未来 家的样子</p>
</blockquote>
<p><img src="https://github.com/xiyouMc/xiyoumc.github.io/blob/master/images/home.jpg?raw=true" alt="zls"></p>
<a id="more"></a>
<blockquote>
<ul>
<li>一直都想有个家、有自己的妻儿</li>
<li>有一个可以依靠、也可以安心的家</li>
<li>So 让我们一起努力。有一天你会是我的妻子，我会是你的丈夫，你我会是孩子的父母。</li>
</ul>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[You are My Sunshine.]]></title>
      <url>https://xiyoumc.github.com/2016/09/02/Sun/</url>
      <content type="html"><![CDATA[<p>我喜欢温暖、你恰好是太阳<br><a id="more"></a></p>
<blockquote>
<p>时间流逝<br>忙碌的项目开发，无数的接口，无数的调试<br>Github也好久没更新<br>不过。。。<br>不过。。。最开心 幸福的事是拥有了你<br>我喜欢温暖、你恰好是太阳</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[平淡]]></title>
      <url>https://xiyoumc.github.com/2016/08/18/822/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/xiyouMc/xiyoumc.github.io/blob/master/images/lover.jpg?raw=true" alt="zls"></p>
<p>少年，我爱上你了<br><a id="more"></a></p>
<p>&lt;告白气球&gt;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[爱情观]]></title>
      <url>https://xiyoumc.github.com/2016/08/18/Lover/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/xiyouMc/xiyoumc.github.io/blob/master/images/shelizi.png?raw=true" alt="zls"></p>
<p>诸心，皆为非心 心中无物、无心，便是真心<br><a id="more"></a></p>
<ul>
<li>佛教劝人学习放下万缘，不要执着感情，却不是要人无情，因为，人本来就是有情众生，只要把爱情的聚散当成因缘变化来看，明白“缘散则散，缘聚则聚”的道理，爱、恨便能在这一念之间转变、释怀。只要是人，就不可能没有感情，佛教称众生为“有情”，就是因为“有爱”的缘故。人活在世界上，除了饮食的养分，还需要精神的滋润，而感情就是最好的精神滋润剂，因此，感情和生命可说是息息相关的。感情虽然带给人很多温暖，却也充满痛苦；相爱的人，感情浓烈，如胶似漆分不开，一旦爱过了头，或失去了爱，就变成了苦；也有人以为只要不动情，就不会为爱所苦，这恐怕是一厢情愿的想法，既然情爱和生命息息相关，无论是否定它，或硬生生地把它切断，既不合乎佛法的因果，也不合乎人情的道理。佛教虽然劝人学习放下万缘，不要执着感情，却不是要人无情，因为，人本来就是有情众生。</li>
</ul>
<ul>
<li>遇上触礁的爱情<blockquote>
<p>然而，男女间的感情，往往非自己的期待所能控制。假如有一天，你的女朋友或是男朋友突然跟你说：“对不起！我已经遇到更适合的人，请你以后不要再来找我。”你会不会觉得晴天霹雳？觉得自己被背叛、被抛弃了？失恋的人，常常悲观地觉得生不如死：“连我最爱的人都不要我了，我还活下去做什么？” 有时候甚至还会骂说：“哼！你不要我，我本来就不想要你了。”或是“真是有眼无珠。”<br>有人为情轻生，结束自己的生命；有人为情杀人，抱着“你让我这样痛苦，我也不让你快活”；或是“我得不到你，天下人也甭想得到你”的偏激心理，而把对方杀了，甚至有的在杀了对方之后，自己也跟着自杀。大多数的人都知道，爱情是双向的，既然如此，如果对方不爱你，就不要苦苦追求不舍，应该知趣地离开，可是，有些人偏偏就是死心眼，非卿不娶，非君不嫁，不但为对方带来困扰，也让自己陷入困境。话虽这么说，毕竟人非草木，谁能无情？一般的人，仍常常为情所苦，可见得要放下感情，其实是件很不容易的事。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>以因缘观化解爱恨* </p>
<blockquote>
<p>因爱而生怨、生恨是很不幸的，从佛法的观点来看，这些都是愚痴的行为，因为真正的爱情要双方你情我愿，有因有缘才能成就，不是自己想要就要。假使对方已经明白拒绝你的感情，自己却还想尽办法，想把对方追回来；就好像赌输的人一样，心中不服气，老是想翻本，钱输光了就想办法再借，也因而愈陷愈深，不可自拔，既然知道无法挽回，就不要再陷下去了，应该赶快撤退，就算是以此为戒，至少学到经验，也就够了，这样就是对自己慈悲。慈悲不仅是照顾别人，事实上，也是在保护自己。当爱情受到挫折时，应试着化解自己心中的愤怒、不平。佛法当中“空”的观念，是最能够助人摆脱痛苦的。只要把爱情的聚散当成因缘变化来看，明白“缘散则散，缘聚则聚”的道理，爱、恨便能在这一念之间转变、释怀。</p>
</blockquote>
</li>
<li><p>陷入痛苦的爱情</p>
<blockquote>
<p>为什么爱情要俘虏人呢？很多情侣往往会说：“我爱你爱得要死！”或是喜欢说：“我是你的一半，你是我的一半！” 明明是不同的两个人，却彼此互相要求对方，成为自己的一部分，这种“爱”，都希望既要俘虏对方的人，也要俘虏对方的心；控制他的行动，还要控制他的心。所谓“俘虏”，其实就是占有，就是把自我价值扩展到他人身上。男女间的爱，本来就是一种互相的占有。你想占有他，他也想占有你，因为都想占有，所以就分不开了，这样的“爱”，到头来，却只让对方更想逃走。<br>此外，很多人谈恋爱，其实是想找个依靠，也就是找“靠山”的心态。我要靠我的男朋友、我要靠我的女朋友、我要靠我的丈夫、我要靠我的太太，刚开始，依赖一下、靠一靠，可能觉得很温馨。可是，靠久了，对方可能就会想：“怎么老是要靠我？我好累喔！” 偶尔靠一靠是甜蜜的，但老是靠着，就会成了对方的麻烦和负担。即使在爱情的两人世界中，每个人都还是独立的自我，不管是男的还是女的，每个人都怕别人变成自己的负担，如果不能够独立，只想要依靠或是指望另一半，就会成了对方的包袱。</p>
</blockquote>
</li>
<li><p>以尊重的心态经营爱情</p>
<blockquote>
<p>真正的爱情应该是无私的付出，但是多半的爱情还是以占有、控制为出发点，这和人的不安全感有关，因此，要求情人对你做到全心的奉献，恐怕是很困难的事。也因如此，甜蜜的爱情，却往往是最痛苦的。期待、要求，希望得到对方“真心”的对待和付出，可是，这种心是“真心”吗？《金刚经》中有一段话：“如来说诸心，皆为非心，是名为心。”“诸心”，是指每一个众生的种种心理活动现象，这些都是虚妄的，从佛法的观点来看，只要有心，就都不是真心，要“心无所住”，心中无物、无心，那才是“真心”。所以说，占有心、依靠心、期待心，都不叫“真心”，而是“烦恼心”。</p>
</blockquote>
</li>
<li><p>古人说“相敬如宾”，虽是老生常谈，却是能够维系长久爱情的真正智慧。如果想避免吵架、误解，或者是想消融不断的期待、要求，在遇到诸如此类的问题时，不妨以尊重的心态，心悦诚服、欢欢喜喜、平平静静去面对、解决，心中的纠结，其实在当下都能即得化解。爱情里的关系，并不是在互相执着、纠缠和占有，而是互相的贡献、成长和学习。能够互相关怀、照顾、包容，去彼此计较、相互猜疑，多沟通，并相互信赖，才能成为菩萨伴侣。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hybrid调试指南]]></title>
      <url>https://xiyoumc.github.com/2016/08/17/hybrid%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/xiyouMc/HybridApp/blob/master/%20hybrid.png?raw=true" alt="inspect1"></p>
<h1 id="Hybrid调试指南"><a href="#Hybrid调试指南" class="headerlink" title="Hybrid调试指南"></a>Hybrid调试指南</h1><blockquote>
<p>开发接口过程中如何自测接口?</p>
</blockquote>
<a id="more"></a>
<h2 id="Dependency"><a href="#Dependency" class="headerlink" title="Dependency"></a>Dependency</h2><blockquote>
<ul>
<li>Chrome</li>
<li>Android SDK Level &gt;=19</li>
</ul>
</blockquote>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><blockquote>
<ul>
<li>Android设备连接电脑，并打开USB调试</li>
<li>通过Hybrid打开任意页面</li>
<li>使用Chrome浏览器打开，<a href="chrome://inspect" target="_blank" rel="external">chrome://inspect</a>,  调用JSBridge对应的接口</li>
</ul>
</blockquote>
<h2 id="Picture"><a href="#Picture" class="headerlink" title="Picture"></a>Picture</h2><blockquote>
<ul>
<li>以下是 “隐藏TitleBar”为例，通过JSBridge来隐藏Native的标题栏</li>
</ul>
</blockquote>
<ul>
<li>打开Console控制台</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiyouMc/HybridApp/master/images/inspect1.png" alt="inspect1"></p>
<ul>
<li>注入JSBridge.call(“hideTitlebar”);</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiyouMc/HybridApp/master/images/inspect2.png" alt="inspect2"></p>
<ul>
<li>App端隐藏掉Titlebar</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiyouMc/HybridApp/master/images/hideTitlebar.png" alt="hideTitle"></p>
<ul>
<li>通过Hybrid打开任意页面，测试页面-Slideplus素材中心页</li>
<li>使用Chrome浏览器打开，<a href="chrome://inspect" target="_blank" rel="external">chrome://inspect</a></li>
</ul>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><p>&gt;</p>
<ul>
<li>JSBridge.call(“hideTitlebar”)  —Hide Title bar</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[插件化框架简介]]></title>
      <url>https://xiyoumc.github.com/2016/05/05/%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>本框架是建立在 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-load-apk</a>进行的上层封装。增加插件动态加载到libs目录和针对模块Service的注入。</p>
<p>本文将以H5Core为插件进行讲解。</p>
<h5 id="更新日志："><a href="#更新日志：" class="headerlink" title="更新日志："></a>更新日志：</h5><p>&gt;</p>
<ul>
<li>2016/7/6  commit -m “增加懒加载功能”   hash: 2a335dc49654c80fb6779cacefdf3ed712c23a8</li>
</ul>
<h1 id="插件化框架简介"><a href="#插件化框架简介" class="headerlink" title="插件化框架简介"></a>插件化框架简介</h1><ul>
<li>插件化是将Apk中功能类似的模块封装到独立的Application中，并根据框架约定好的规则完成Apk的动态加载和Service的注入。</li>
<li>本框架是将每一个Apk作为so并使用定制化打包脚本将so文件打到主Project/libs/jniLibs，这样在apk编译的时候就可以将so文件直接装载进data/data/xxxxx/lib目录，支持后续的DexClassLoader加载该文件。</li>
<li>每一个模块分为Api和Core，Api作为模块对外提供的接口，Core作为封装好的独立模块，每一个模块做好自己的混淆。注入操作需在Core中定义，下文将介绍这块。</li>
<li><p>主Client增加bundleList.config文件，文件配置：</p>
<pre><code>bundleName=h5core    //直接加载的插件
lazyBundle=h5core.H5Service&amp;H5Api //懒加载插件
</code></pre></li>
</ul>
<h2 id="一、Framework"><a href="#一、Framework" class="headerlink" title="一、Framework"></a>一、Framework</h2><ul>
<li>Framework提供了一个动态加载apk的框架，并提供一个加载独立模块的BaseMateinfo。</li>
</ul>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol>
<li>开发模块时需要在  module(core)/package name/下定义Metainfo继承自BaseMateinfo。 这样该模块在主Apk安装的时候就会动态将模块的接口注入到框架，后续提供给其它组件调用。</li>
<li><p>模块提供的主要方法类有:BasePluginActivity,BasePluginFragmentActivity,BasePluginService,BaseMateinfo,MarkApplication.</p>
<pre><code>BasePluginActivity: 基础的Activity，每一个模块中的Activity都需要继承该类，完成模块中的Activity的代理化。
BasePluginFragmentActivity： 基础的FragmentActivity，同上。需要继承该类
BasePluginService: 基础的Service，同上。
BaseMateinfo: 模块Service注入的基类，其它模块的Core层都需要定义一个Metainfo来继承该类，并完成Service的注入。（后面会介绍如何注入）
MarkApplication:模块的Application，可以拿到模块的Context，并提供查找Service，启动Activity等方法。
</code></pre></li>
</ol>
<h2 id="二、Activity层"><a href="#二、Activity层" class="headerlink" title="二、Activity层"></a>二、Activity层</h2><ul>
<li>为了让proxy全面接管apk中所有activity的执行，需要为activity定义一个基类BaseActivity，在基类中处理代理相关的事情，同时BaseActivity还对是否使用代理进行了判断，如果不使用代理，那么activity的逻辑仍然按照正常的方式执行，也就是说，这个apk既可以按照执行，也可以由宿主程序来执行。</li>
</ul>
<h3 id="独立模块架构"><a href="#独立模块架构" class="headerlink" title="独立模块架构"></a>独立模块架构</h3><ul>
<li>模块分类：Api和Core,针对不同业务可追加前缀。</li>
<li>每一个模块对外提供一个Service供其他模块引用。Service的Interface类放在Api模块，实现类放在Core。实现独立模块的封装。</li>
<li><p>Service注册：在Core的根包目录创建MetaInfo类，继承Framework模块的BaseMetaInfo.如下：</p>
<pre><code>public class MetaInfo extends BaseMetaInfo {
private static final String TAG = &quot;MetaInfo.Init&quot;;
public MetaInfo() {
    Log.d(TAG,&quot;Service init&quot;);
    ServiceDescription serviceDescription = new ServiceDescription();
    serviceDescription.setInterfaceName(XXService.class.getName());
    serviceDescription.setClassName(XXServiceImpl.class.getName());
    services.add(serviceDescription);
}
}
注解:
ServiceDescription类是针对Service的描述类，将接口和实现封装在该对象，并将其添加到services列表中。
</code></pre><p>  以上工作就完成了模块的注入。</p>
</li>
</ul>
<h3 id="模块之间依赖"><a href="#模块之间依赖" class="headerlink" title="模块之间依赖"></a>模块之间依赖</h3><ul>
<li>模块只要是通过Api包的依赖进行访问。由于Api是作为一个Jar存在的，因此可以直接被其它模块依赖，并切记使用 provided来依赖，防止Api的jar包被编译进模块。</li>
<li><p>模块之间访问：主要的类有MarkApplication、MicroApplicationContext。</p>
<pre><code>比如其他模块访问Core:
XXService xxservice = MarkApplication.getInstance().getMicroApplicationContext().findServiceByInterface(XXService.class.getName());
这样就可以拿到容器的Service，从而调用其提供的方法。
</code></pre></li>
</ul>
<h3 id="模块内部资源的访问"><a href="#模块内部资源的访问" class="headerlink" title="模块内部资源的访问"></a>模块内部资源的访问</h3><ul>
<li><p>由于每一个模块作为独立的apk打入主apk,因此访问该apk的上下文不再是该apk的，而是框架层的代理上下文。</p>
<pre><code>示例：
1、Resourse获取
    MarkApplication.getInstance().getMicroApplicationContext().getResourcesByBundle(&quot;xxcore&quot;);
2、Assets获取
    MarkApplication.getInstance().getMicroApplicationContext().getAssetsByBundle(&quot;xxcore&quot;);
</code></pre></li>
</ul>
<h3 id="Gradle打包命令详解"><a href="#Gradle打包命令详解" class="headerlink" title="Gradle打包命令详解"></a>Gradle打包命令详解</h3><ul>
<li>gradle build ：编译当前模块。</li>
<li>gradle buidleJar:针对本模块生成jar包，保存目录在  xxx/build/libs/xxxx.jar</li>
<li>gradle uploadArchives:上传本项目包到Nexus服务器，提供给其他模块依赖</li>
</ul>
<p>例子：</p>
<p>1、Api包的<a href="https://github.com/xiyouMc/AppDynamicFramework/blob/master/API.MD" target="_blank" rel="external">build.gradle模版</a><br>2、Core包的 <a href="https://github.com/xiyouMc/AppDynamicFramework/blob/master/CORE.MD" target="_blank" rel="external">build.gradle模版</a></p>
<h2 id="三、依赖关系介绍"><a href="#三、依赖关系介绍" class="headerlink" title="三、依赖关系介绍"></a>三、依赖关系介绍</h2><ul>
<li>如今模块化之后，依赖关系的复杂度也相比之前复杂了不少，因此梳理好依赖关系是必须考虑的问题。</li>
</ul>
<h3 id="模块化主要的依赖关系："><a href="#模块化主要的依赖关系：" class="headerlink" title="模块化主要的依赖关系："></a>模块化主要的依赖关系：</h3><pre><code>框架主要有Portal、Framework、Module三个模块：
1、Portal是项目的Launcher目录。
2、Framework是框架的架构模块。
3、Module是每一个模块，并分为Api和Core，并且Api作为Android.library、Core作为Android.application.
4、每一个模块通过依赖其它模块的Api进行组件的调用。并且每一个Core都需要依赖Framework。
</code></pre><h3 id="插件apk的开发规范"><a href="#插件apk的开发规范" class="headerlink" title="插件apk的开发规范"></a>插件apk的开发规范</h3><p>开发插件apk所需要遵循的规范：</p>
<p><del>1. 不能用this：因为this指向的是当前对象，即apk中的activity，但是由于activity已经不是常规意义上的activity，所以this是没有意义的</del></p>
<p><del>2. 使用that：既然this不能用，那就用that，that是apk中activity的基类BaseActivity中的一个成员，它在apk安装运行的时候指向this，而在未安装的时候指向宿主程序中的代理activity，anyway，that is better than this.</del></p>
<p><del>3. 不能直接调用activity的成员方法：而必须通过that去调用，由于that的动态分配特性，通过that去调用activity的成员方法，在apk安装以后仍然可以正常运行。</del></p>
<ol>
<li>启动新activity的约束：启动外部activity不受限制，启动apk内部的activity有限制，首先由于apk中的activity没注册，所以不支持隐式调用，其次必须通过BaseActivity中定义的新方法startActivityByProxy和startActivityForResultByProxy，还有就是不支持LaunchMode。</li>
<li>目前暂不支持Service、BroadcastReceiver等需要注册才能使用的组件。</li>
</ol>
<h2 id="四、更新功能"><a href="#四、更新功能" class="headerlink" title="四、更新功能"></a>四、更新功能</h2><ul>
<li><p>2016/7/6 懒加载功能</p>
<pre><code>1、bundleList.config 文件增加lazyBundle字段来标示是否进行懒加载。字段值格式：bundleName.bundleService*bundleService。这样在该插件被调用的时候，框架采取load这个dex。    
2、优化效果：681kb的so，首次启动懒加载优化100ms。
</code></pre></li>
</ul>
<p>Thankd for your reading, by Mc…    Thanks Dynamic-load-apk</p>
<p>update</p>
<h2 id="Contact-me"><a href="#Contact-me" class="headerlink" title="Contact me"></a>Contact me</h2><p>Any further question?</p>
<p><a href="mailto:tmac694449212@gmail.com" target="_blank" rel="external">Email</a> me please!</p>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><pre><code>Copyright 2016 xiyouMc

Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
</code></pre>]]></content>
    </entry>
    
  
  
</search>
